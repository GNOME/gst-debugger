// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gstdebugger.proto

#ifndef PROTOBUF_gstdebugger_2eproto__INCLUDED
#define PROTOBUF_gstdebugger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace GstDebugger {
class BufferHookRequest;
class BufferHookRequestDefaultTypeInternal;
extern BufferHookRequestDefaultTypeInternal _BufferHookRequest_default_instance_;
class BufferInfo;
class BufferInfoDefaultTypeInternal;
extern BufferInfoDefaultTypeInternal _BufferInfo_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class DebugCategories;
class DebugCategoriesDefaultTypeInternal;
extern DebugCategoriesDefaultTypeInternal _DebugCategories_default_instance_;
class ElementKlass;
class ElementKlassDefaultTypeInternal;
extern ElementKlassDefaultTypeInternal _ElementKlass_default_instance_;
class EnumFlagsType;
class EnumFlagsTypeDefaultTypeInternal;
extern EnumFlagsTypeDefaultTypeInternal _EnumFlagsType_default_instance_;
class EnumFlagsValue;
class EnumFlagsValueDefaultTypeInternal;
extern EnumFlagsValueDefaultTypeInternal _EnumFlagsValue_default_instance_;
class EventHookRequest;
class EventHookRequestDefaultTypeInternal;
extern EventHookRequestDefaultTypeInternal _EventHookRequest_default_instance_;
class EventInfo;
class EventInfoDefaultTypeInternal;
extern EventInfoDefaultTypeInternal _EventInfo_default_instance_;
class FactoryMeta;
class FactoryMetaDefaultTypeInternal;
extern FactoryMetaDefaultTypeInternal _FactoryMeta_default_instance_;
class FactoryType;
class FactoryTypeDefaultTypeInternal;
extern FactoryTypeDefaultTypeInternal _FactoryType_default_instance_;
class GStreamerData;
class GStreamerDataDefaultTypeInternal;
extern GStreamerDataDefaultTypeInternal _GStreamerData_default_instance_;
class HookRequest;
class HookRequestDefaultTypeInternal;
extern HookRequestDefaultTypeInternal _HookRequest_default_instance_;
class LogInfo;
class LogInfoDefaultTypeInternal;
extern LogInfoDefaultTypeInternal _LogInfo_default_instance_;
class LogRequest;
class LogRequestDefaultTypeInternal;
extern LogRequestDefaultTypeInternal _LogRequest_default_instance_;
class MessageInfo;
class MessageInfoDefaultTypeInternal;
extern MessageInfoDefaultTypeInternal _MessageInfo_default_instance_;
class MessageRequest;
class MessageRequestDefaultTypeInternal;
extern MessageRequestDefaultTypeInternal _MessageRequest_default_instance_;
class PadDynamicInfo;
class PadDynamicInfoDefaultTypeInternal;
extern PadDynamicInfoDefaultTypeInternal _PadDynamicInfo_default_instance_;
class PadHookRequest;
class PadHookRequestDefaultTypeInternal;
extern PadHookRequestDefaultTypeInternal _PadHookRequest_default_instance_;
class PadTemplate;
class PadTemplateDefaultTypeInternal;
extern PadTemplateDefaultTypeInternal _PadTemplate_default_instance_;
class PropertyInfo;
class PropertyInfoDefaultTypeInternal;
extern PropertyInfoDefaultTypeInternal _PropertyInfo_default_instance_;
class PropertyRequest;
class PropertyRequestDefaultTypeInternal;
extern PropertyRequestDefaultTypeInternal _PropertyRequest_default_instance_;
class PropertyValue;
class PropertyValueDefaultTypeInternal;
extern PropertyValueDefaultTypeInternal _PropertyValue_default_instance_;
class QueryHookRequest;
class QueryHookRequestDefaultTypeInternal;
extern QueryHookRequestDefaultTypeInternal _QueryHookRequest_default_instance_;
class QueryInfo;
class QueryInfoDefaultTypeInternal;
extern QueryInfoDefaultTypeInternal _QueryInfo_default_instance_;
class TopologyElement;
class TopologyElementDefaultTypeInternal;
extern TopologyElementDefaultTypeInternal _TopologyElement_default_instance_;
class TopologyInfo;
class TopologyInfoDefaultTypeInternal;
extern TopologyInfoDefaultTypeInternal _TopologyInfo_default_instance_;
class TopologyLink;
class TopologyLinkDefaultTypeInternal;
extern TopologyLinkDefaultTypeInternal _TopologyLink_default_instance_;
class TopologyPad;
class TopologyPadDefaultTypeInternal;
extern TopologyPadDefaultTypeInternal _TopologyPad_default_instance_;
class TypeDescriptionRequest;
class TypeDescriptionRequestDefaultTypeInternal;
extern TypeDescriptionRequestDefaultTypeInternal _TypeDescriptionRequest_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace GstDebugger

namespace GstDebugger {

namespace protobuf_gstdebugger_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_gstdebugger_2eproto

enum TypeDescriptionRequest_Type {
  TypeDescriptionRequest_Type_FACTORY = 0,
  TypeDescriptionRequest_Type_ENUM_FLAGS = 1,
  TypeDescriptionRequest_Type_KLASS = 2
};
bool TypeDescriptionRequest_Type_IsValid(int value);
const TypeDescriptionRequest_Type TypeDescriptionRequest_Type_Type_MIN = TypeDescriptionRequest_Type_FACTORY;
const TypeDescriptionRequest_Type TypeDescriptionRequest_Type_Type_MAX = TypeDescriptionRequest_Type_KLASS;
const int TypeDescriptionRequest_Type_Type_ARRAYSIZE = TypeDescriptionRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TypeDescriptionRequest_Type_descriptor();
inline const ::std::string& TypeDescriptionRequest_Type_Name(TypeDescriptionRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TypeDescriptionRequest_Type_descriptor(), value);
}
inline bool TypeDescriptionRequest_Type_Parse(
    const ::std::string& name, TypeDescriptionRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeDescriptionRequest_Type>(
    TypeDescriptionRequest_Type_descriptor(), name, value);
}
enum EnumFlagsType_EnumFlagsKind {
  EnumFlagsType_EnumFlagsKind_ENUM = 0,
  EnumFlagsType_EnumFlagsKind_FLAGS = 1
};
bool EnumFlagsType_EnumFlagsKind_IsValid(int value);
const EnumFlagsType_EnumFlagsKind EnumFlagsType_EnumFlagsKind_EnumFlagsKind_MIN = EnumFlagsType_EnumFlagsKind_ENUM;
const EnumFlagsType_EnumFlagsKind EnumFlagsType_EnumFlagsKind_EnumFlagsKind_MAX = EnumFlagsType_EnumFlagsKind_FLAGS;
const int EnumFlagsType_EnumFlagsKind_EnumFlagsKind_ARRAYSIZE = EnumFlagsType_EnumFlagsKind_EnumFlagsKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* EnumFlagsType_EnumFlagsKind_descriptor();
inline const ::std::string& EnumFlagsType_EnumFlagsKind_Name(EnumFlagsType_EnumFlagsKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    EnumFlagsType_EnumFlagsKind_descriptor(), value);
}
inline bool EnumFlagsType_EnumFlagsKind_Parse(
    const ::std::string& name, EnumFlagsType_EnumFlagsKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EnumFlagsType_EnumFlagsKind>(
    EnumFlagsType_EnumFlagsKind_descriptor(), name, value);
}
enum Action {
  ADD = 0,
  REMOVE = 1
};
bool Action_IsValid(int value);
const Action Action_MIN = ADD;
const Action Action_MAX = REMOVE;
const int Action_ARRAYSIZE = Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_descriptor();
inline const ::std::string& Action_Name(Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_descriptor(), value);
}
inline bool Action_Parse(
    const ::std::string& name, Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action>(
    Action_descriptor(), name, value);
}
// ===================================================================

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  inline Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required string type_name = 4;
  bool has_type_name() const;
  void clear_type_name();
  static const int kTypeNameFieldNumber = 4;
  const ::std::string& type_name() const;
  void set_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_type_name(::std::string&& value);
  #endif
  void set_type_name(const char* value);
  void set_type_name(const char* value, size_t size);
  ::std::string* mutable_type_name();
  ::std::string* release_type_name();
  void set_allocated_type_name(::std::string* type_name);

  // required uint64 gtype = 1;
  bool has_gtype() const;
  void clear_gtype();
  static const int kGtypeFieldNumber = 1;
  ::google::protobuf::uint64 gtype() const;
  void set_gtype(::google::protobuf::uint64 value);

  // optional int32 internal_type = 2;
  bool has_internal_type() const;
  void clear_internal_type();
  static const int kInternalTypeFieldNumber = 2;
  ::google::protobuf::int32 internal_type() const;
  void set_internal_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.Value)
 private:
  void set_has_gtype();
  void clear_has_gtype();
  void set_has_internal_type();
  void clear_has_internal_type();
  void set_has_data();
  void clear_has_data();
  void set_has_type_name();
  void clear_has_type_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr type_name_;
  ::google::protobuf::uint64 gtype_;
  ::google::protobuf::int32 internal_type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropertyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PropertyInfo) */ {
 public:
  PropertyInfo();
  virtual ~PropertyInfo();

  PropertyInfo(const PropertyInfo& from);

  inline PropertyInfo& operator=(const PropertyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyInfo& default_instance();

  static inline const PropertyInfo* internal_default_instance() {
    return reinterpret_cast<const PropertyInfo*>(
               &_PropertyInfo_default_instance_);
  }

  void Swap(PropertyInfo* other);

  // implements Message ----------------------------------------------

  inline PropertyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PropertyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropertyInfo& from);
  void MergeFrom(const PropertyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropertyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string nick = 2;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 2;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const char* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);

  // required string blurb = 3;
  bool has_blurb() const;
  void clear_blurb();
  static const int kBlurbFieldNumber = 3;
  const ::std::string& blurb() const;
  void set_blurb(const ::std::string& value);
  #if LANG_CXX11
  void set_blurb(::std::string&& value);
  #endif
  void set_blurb(const char* value);
  void set_blurb(const char* value, size_t size);
  ::std::string* mutable_blurb();
  ::std::string* release_blurb();
  void set_allocated_blurb(::std::string* blurb);

  // required .GstDebugger.Value default_value = 5;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 5;
  const ::GstDebugger::Value& default_value() const;
  ::GstDebugger::Value* mutable_default_value();
  ::GstDebugger::Value* release_default_value();
  void set_allocated_default_value(::GstDebugger::Value* default_value);

  // required int32 flags = 4;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 4;
  ::google::protobuf::int32 flags() const;
  void set_flags(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.PropertyInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_nick();
  void clear_has_nick();
  void set_has_blurb();
  void clear_has_blurb();
  void set_has_flags();
  void clear_has_flags();
  void set_has_default_value();
  void clear_has_default_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::internal::ArenaStringPtr blurb_;
  ::GstDebugger::Value* default_value_;
  ::google::protobuf::int32 flags_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropertyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PropertyValue) */ {
 public:
  PropertyValue();
  virtual ~PropertyValue();

  PropertyValue(const PropertyValue& from);

  inline PropertyValue& operator=(const PropertyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyValue& default_instance();

  static inline const PropertyValue* internal_default_instance() {
    return reinterpret_cast<const PropertyValue*>(
               &_PropertyValue_default_instance_);
  }

  void Swap(PropertyValue* other);

  // implements Message ----------------------------------------------

  inline PropertyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  PropertyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropertyValue& from);
  void MergeFrom(const PropertyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropertyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string object = 2;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  #if LANG_CXX11
  void set_object(::std::string&& value);
  #endif
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // required .GstDebugger.Value value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::GstDebugger::Value& value() const;
  ::GstDebugger::Value* mutable_value();
  ::GstDebugger::Value* release_value();
  void set_allocated_value(::GstDebugger::Value* value);

  // @@protoc_insertion_point(class_scope:GstDebugger.PropertyValue)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_object();
  void clear_has_object();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  ::GstDebugger::Value* value_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropertyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PropertyRequest) */ {
 public:
  PropertyRequest();
  virtual ~PropertyRequest();

  PropertyRequest(const PropertyRequest& from);

  inline PropertyRequest& operator=(const PropertyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PropertyRequest& default_instance();

  static inline const PropertyRequest* internal_default_instance() {
    return reinterpret_cast<const PropertyRequest*>(
               &_PropertyRequest_default_instance_);
  }

  void Swap(PropertyRequest* other);

  // implements Message ----------------------------------------------

  inline PropertyRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PropertyRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PropertyRequest& from);
  void MergeFrom(const PropertyRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PropertyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string object = 2;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  #if LANG_CXX11
  void set_object(::std::string&& value);
  #endif
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // @@protoc_insertion_point(class_scope:GstDebugger.PropertyRequest)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_object();
  void clear_has_object();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.MessageInfo) */ {
 public:
  MessageInfo();
  virtual ~MessageInfo();

  MessageInfo(const MessageInfo& from);

  inline MessageInfo& operator=(const MessageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageInfo& default_instance();

  static inline const MessageInfo* internal_default_instance() {
    return reinterpret_cast<const MessageInfo*>(
               &_MessageInfo_default_instance_);
  }

  void Swap(MessageInfo* other);

  // implements Message ----------------------------------------------

  inline MessageInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageInfo& from);
  void MergeFrom(const MessageInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string source = 3;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 3;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  #if LANG_CXX11
  void set_source(::std::string&& value);
  #endif
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // required bytes structure_data = 5;
  bool has_structure_data() const;
  void clear_structure_data();
  static const int kStructureDataFieldNumber = 5;
  const ::std::string& structure_data() const;
  void set_structure_data(const ::std::string& value);
  #if LANG_CXX11
  void set_structure_data(::std::string&& value);
  #endif
  void set_structure_data(const char* value);
  void set_structure_data(const void* value, size_t size);
  ::std::string* mutable_structure_data();
  ::std::string* release_structure_data();
  void set_allocated_structure_data(::std::string* structure_data);

  // required uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required uint32 seqnum = 4;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 4;
  ::google::protobuf::uint32 seqnum() const;
  void set_seqnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.MessageInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_source();
  void clear_has_source();
  void set_has_seqnum();
  void clear_has_seqnum();
  void set_has_structure_data();
  void clear_has_structure_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  ::google::protobuf::internal::ArenaStringPtr structure_data_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint32 seqnum_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.EventInfo) */ {
 public:
  EventInfo();
  virtual ~EventInfo();

  EventInfo(const EventInfo& from);

  inline EventInfo& operator=(const EventInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventInfo& default_instance();

  static inline const EventInfo* internal_default_instance() {
    return reinterpret_cast<const EventInfo*>(
               &_EventInfo_default_instance_);
  }

  void Swap(EventInfo* other);

  // implements Message ----------------------------------------------

  inline EventInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EventInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventInfo& from);
  void MergeFrom(const EventInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pad = 4;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 4;
  const ::std::string& pad() const;
  void set_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_pad(::std::string&& value);
  #endif
  void set_pad(const char* value);
  void set_pad(const char* value, size_t size);
  ::std::string* mutable_pad();
  ::std::string* release_pad();
  void set_allocated_pad(::std::string* pad);

  // required bytes structure_data = 5;
  bool has_structure_data() const;
  void clear_structure_data();
  static const int kStructureDataFieldNumber = 5;
  const ::std::string& structure_data() const;
  void set_structure_data(const ::std::string& value);
  #if LANG_CXX11
  void set_structure_data(::std::string&& value);
  #endif
  void set_structure_data(const char* value);
  void set_structure_data(const void* value, size_t size);
  ::std::string* mutable_structure_data();
  ::std::string* release_structure_data();
  void set_allocated_structure_data(::std::string* structure_data);

  // required uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // required uint32 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::uint32 seqnum() const;
  void set_seqnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.EventInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_seqnum();
  void clear_has_seqnum();
  void set_has_pad();
  void clear_has_pad();
  void set_has_structure_data();
  void clear_has_structure_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pad_;
  ::google::protobuf::internal::ArenaStringPtr structure_data_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint32 seqnum_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.QueryInfo) */ {
 public:
  QueryInfo();
  virtual ~QueryInfo();

  QueryInfo(const QueryInfo& from);

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryInfo& default_instance();

  static inline const QueryInfo* internal_default_instance() {
    return reinterpret_cast<const QueryInfo*>(
               &_QueryInfo_default_instance_);
  }

  void Swap(QueryInfo* other);

  // implements Message ----------------------------------------------

  inline QueryInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryInfo& from);
  void MergeFrom(const QueryInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pad = 2;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 2;
  const ::std::string& pad() const;
  void set_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_pad(::std::string&& value);
  #endif
  void set_pad(const char* value);
  void set_pad(const char* value, size_t size);
  ::std::string* mutable_pad();
  ::std::string* release_pad();
  void set_allocated_pad(::std::string* pad);

  // required bytes structure_data = 3;
  bool has_structure_data() const;
  void clear_structure_data();
  static const int kStructureDataFieldNumber = 3;
  const ::std::string& structure_data() const;
  void set_structure_data(const ::std::string& value);
  #if LANG_CXX11
  void set_structure_data(::std::string&& value);
  #endif
  void set_structure_data(const char* value);
  void set_structure_data(const void* value, size_t size);
  ::std::string* mutable_structure_data();
  ::std::string* release_structure_data();
  void set_allocated_structure_data(::std::string* structure_data);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.QueryInfo)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_pad();
  void clear_has_pad();
  void set_has_structure_data();
  void clear_has_structure_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pad_;
  ::google::protobuf::internal::ArenaStringPtr structure_data_;
  ::google::protobuf::int32 type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.BufferInfo) */ {
 public:
  BufferInfo();
  virtual ~BufferInfo();

  BufferInfo(const BufferInfo& from);

  inline BufferInfo& operator=(const BufferInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferInfo& default_instance();

  static inline const BufferInfo* internal_default_instance() {
    return reinterpret_cast<const BufferInfo*>(
               &_BufferInfo_default_instance_);
  }

  void Swap(BufferInfo* other);

  // implements Message ----------------------------------------------

  inline BufferInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BufferInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BufferInfo& from);
  void MergeFrom(const BufferInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BufferInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pad = 7;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 7;
  const ::std::string& pad() const;
  void set_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_pad(::std::string&& value);
  #endif
  void set_pad(const char* value);
  void set_pad(const char* value, size_t size);
  ::std::string* mutable_pad();
  ::std::string* release_pad();
  void set_allocated_pad(::std::string* pad);

  // optional bytes data = 8;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 8;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required uint64 pts = 1;
  bool has_pts() const;
  void clear_pts();
  static const int kPtsFieldNumber = 1;
  ::google::protobuf::uint64 pts() const;
  void set_pts(::google::protobuf::uint64 value);

  // required uint64 dts = 2;
  bool has_dts() const;
  void clear_dts();
  static const int kDtsFieldNumber = 2;
  ::google::protobuf::uint64 dts() const;
  void set_dts(::google::protobuf::uint64 value);

  // required uint64 duration = 3;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint64 duration() const;
  void set_duration(::google::protobuf::uint64 value);

  // required uint64 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // required uint64 offset_end = 5;
  bool has_offset_end() const;
  void clear_offset_end();
  static const int kOffsetEndFieldNumber = 5;
  ::google::protobuf::uint64 offset_end() const;
  void set_offset_end(::google::protobuf::uint64 value);

  // required uint64 size = 6;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 6;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.BufferInfo)
 private:
  void set_has_pts();
  void clear_has_pts();
  void set_has_dts();
  void clear_has_dts();
  void set_has_duration();
  void clear_has_duration();
  void set_has_offset();
  void clear_has_offset();
  void set_has_offset_end();
  void clear_has_offset_end();
  void set_has_size();
  void clear_has_size();
  void set_has_pad();
  void clear_has_pad();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pad_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 pts_;
  ::google::protobuf::uint64 dts_;
  ::google::protobuf::uint64 duration_;
  ::google::protobuf::uint64 offset_;
  ::google::protobuf::uint64 offset_end_;
  ::google::protobuf::uint64 size_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TypeDescriptionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.TypeDescriptionRequest) */ {
 public:
  TypeDescriptionRequest();
  virtual ~TypeDescriptionRequest();

  TypeDescriptionRequest(const TypeDescriptionRequest& from);

  inline TypeDescriptionRequest& operator=(const TypeDescriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeDescriptionRequest& default_instance();

  static inline const TypeDescriptionRequest* internal_default_instance() {
    return reinterpret_cast<const TypeDescriptionRequest*>(
               &_TypeDescriptionRequest_default_instance_);
  }

  void Swap(TypeDescriptionRequest* other);

  // implements Message ----------------------------------------------

  inline TypeDescriptionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TypeDescriptionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TypeDescriptionRequest& from);
  void MergeFrom(const TypeDescriptionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TypeDescriptionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TypeDescriptionRequest_Type Type;
  static const Type FACTORY =
    TypeDescriptionRequest_Type_FACTORY;
  static const Type ENUM_FLAGS =
    TypeDescriptionRequest_Type_ENUM_FLAGS;
  static const Type KLASS =
    TypeDescriptionRequest_Type_KLASS;
  static inline bool Type_IsValid(int value) {
    return TypeDescriptionRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TypeDescriptionRequest_Type_Type_MIN;
  static const Type Type_MAX =
    TypeDescriptionRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TypeDescriptionRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TypeDescriptionRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TypeDescriptionRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TypeDescriptionRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .GstDebugger.TypeDescriptionRequest.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::GstDebugger::TypeDescriptionRequest_Type type() const;
  void set_type(::GstDebugger::TypeDescriptionRequest_Type value);

  // @@protoc_insertion_point(class_scope:GstDebugger.TypeDescriptionRequest)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryHookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.QueryHookRequest) */ {
 public:
  QueryHookRequest();
  virtual ~QueryHookRequest();

  QueryHookRequest(const QueryHookRequest& from);

  inline QueryHookRequest& operator=(const QueryHookRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryHookRequest& default_instance();

  static inline const QueryHookRequest* internal_default_instance() {
    return reinterpret_cast<const QueryHookRequest*>(
               &_QueryHookRequest_default_instance_);
  }

  void Swap(QueryHookRequest* other);

  // implements Message ----------------------------------------------

  inline QueryHookRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryHookRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryHookRequest& from);
  void MergeFrom(const QueryHookRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryHookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.QueryHookRequest)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferHookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.BufferHookRequest) */ {
 public:
  BufferHookRequest();
  virtual ~BufferHookRequest();

  BufferHookRequest(const BufferHookRequest& from);

  inline BufferHookRequest& operator=(const BufferHookRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferHookRequest& default_instance();

  static inline const BufferHookRequest* internal_default_instance() {
    return reinterpret_cast<const BufferHookRequest*>(
               &_BufferHookRequest_default_instance_);
  }

  void Swap(BufferHookRequest* other);

  // implements Message ----------------------------------------------

  inline BufferHookRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BufferHookRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BufferHookRequest& from);
  void MergeFrom(const BufferHookRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BufferHookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool send_data = 1;
  bool has_send_data() const;
  void clear_send_data();
  static const int kSendDataFieldNumber = 1;
  bool send_data() const;
  void set_send_data(bool value);

  // @@protoc_insertion_point(class_scope:GstDebugger.BufferHookRequest)
 private:
  void set_has_send_data();
  void clear_has_send_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool send_data_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EventHookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.EventHookRequest) */ {
 public:
  EventHookRequest();
  virtual ~EventHookRequest();

  EventHookRequest(const EventHookRequest& from);

  inline EventHookRequest& operator=(const EventHookRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventHookRequest& default_instance();

  static inline const EventHookRequest* internal_default_instance() {
    return reinterpret_cast<const EventHookRequest*>(
               &_EventHookRequest_default_instance_);
  }

  void Swap(EventHookRequest* other);

  // implements Message ----------------------------------------------

  inline EventHookRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EventHookRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventHookRequest& from);
  void MergeFrom(const EventHookRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventHookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.EventHookRequest)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PadHookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PadHookRequest) */ {
 public:
  PadHookRequest();
  virtual ~PadHookRequest();

  PadHookRequest(const PadHookRequest& from);

  inline PadHookRequest& operator=(const PadHookRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PadHookRequest& default_instance();

  enum PadHookTypeCase {
    kQuery = 2,
    kBuffer = 3,
    kEvent = 4,
    PAD_HOOK_TYPE_NOT_SET = 0,
  };

  static inline const PadHookRequest* internal_default_instance() {
    return reinterpret_cast<const PadHookRequest*>(
               &_PadHookRequest_default_instance_);
  }

  void Swap(PadHookRequest* other);

  // implements Message ----------------------------------------------

  inline PadHookRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PadHookRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PadHookRequest& from);
  void MergeFrom(const PadHookRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PadHookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pad = 1;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 1;
  const ::std::string& pad() const;
  void set_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_pad(::std::string&& value);
  #endif
  void set_pad(const char* value);
  void set_pad(const char* value, size_t size);
  ::std::string* mutable_pad();
  ::std::string* release_pad();
  void set_allocated_pad(::std::string* pad);

  // optional .GstDebugger.QueryHookRequest query = 2;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  const ::GstDebugger::QueryHookRequest& query() const;
  ::GstDebugger::QueryHookRequest* mutable_query();
  ::GstDebugger::QueryHookRequest* release_query();
  void set_allocated_query(::GstDebugger::QueryHookRequest* query);

  // optional .GstDebugger.BufferHookRequest buffer = 3;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 3;
  const ::GstDebugger::BufferHookRequest& buffer() const;
  ::GstDebugger::BufferHookRequest* mutable_buffer();
  ::GstDebugger::BufferHookRequest* release_buffer();
  void set_allocated_buffer(::GstDebugger::BufferHookRequest* buffer);

  // optional .GstDebugger.EventHookRequest event = 4;
  bool has_event() const;
  void clear_event();
  static const int kEventFieldNumber = 4;
  const ::GstDebugger::EventHookRequest& event() const;
  ::GstDebugger::EventHookRequest* mutable_event();
  ::GstDebugger::EventHookRequest* release_event();
  void set_allocated_event(::GstDebugger::EventHookRequest* event);

  PadHookTypeCase pad_hook_type_case() const;
  // @@protoc_insertion_point(class_scope:GstDebugger.PadHookRequest)
 private:
  void set_has_pad();
  void clear_has_pad();
  void set_has_query();
  void set_has_buffer();
  void set_has_event();

  inline bool has_pad_hook_type() const;
  void clear_pad_hook_type();
  inline void clear_has_pad_hook_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pad_;
  union PadHookTypeUnion {
    PadHookTypeUnion() {}
    ::GstDebugger::QueryHookRequest* query_;
    ::GstDebugger::BufferHookRequest* buffer_;
    ::GstDebugger::EventHookRequest* event_;
  } pad_hook_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.LogRequest) */ {
 public:
  LogRequest();
  virtual ~LogRequest();

  LogRequest(const LogRequest& from);

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogRequest& default_instance();

  static inline const LogRequest* internal_default_instance() {
    return reinterpret_cast<const LogRequest*>(
               &_LogRequest_default_instance_);
  }

  void Swap(LogRequest* other);

  // implements Message ----------------------------------------------

  inline LogRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LogRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogRequest& from);
  void MergeFrom(const LogRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string category = 2;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 2;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.LogRequest)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_category();
  void clear_has_category();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::int32 level_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.MessageRequest) */ {
 public:
  MessageRequest();
  virtual ~MessageRequest();

  MessageRequest(const MessageRequest& from);

  inline MessageRequest& operator=(const MessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageRequest& default_instance();

  static inline const MessageRequest* internal_default_instance() {
    return reinterpret_cast<const MessageRequest*>(
               &_MessageRequest_default_instance_);
  }

  void Swap(MessageRequest* other);

  // implements Message ----------------------------------------------

  inline MessageRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageRequest& from);
  void MergeFrom(const MessageRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.MessageRequest)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HookRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.HookRequest) */ {
 public:
  HookRequest();
  virtual ~HookRequest();

  HookRequest(const HookRequest& from);

  inline HookRequest& operator=(const HookRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HookRequest& default_instance();

  enum HookTypeCase {
    kMessage = 2,
    kLog = 3,
    kPadHook = 4,
    HOOK_TYPE_NOT_SET = 0,
  };

  static inline const HookRequest* internal_default_instance() {
    return reinterpret_cast<const HookRequest*>(
               &_HookRequest_default_instance_);
  }

  void Swap(HookRequest* other);

  // implements Message ----------------------------------------------

  inline HookRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HookRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HookRequest& from);
  void MergeFrom(const HookRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HookRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .GstDebugger.Action action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::GstDebugger::Action action() const;
  void set_action(::GstDebugger::Action value);

  // optional .GstDebugger.MessageRequest message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::GstDebugger::MessageRequest& message() const;
  ::GstDebugger::MessageRequest* mutable_message();
  ::GstDebugger::MessageRequest* release_message();
  void set_allocated_message(::GstDebugger::MessageRequest* message);

  // optional .GstDebugger.LogRequest log = 3;
  bool has_log() const;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::GstDebugger::LogRequest& log() const;
  ::GstDebugger::LogRequest* mutable_log();
  ::GstDebugger::LogRequest* release_log();
  void set_allocated_log(::GstDebugger::LogRequest* log);

  // optional .GstDebugger.PadHookRequest pad_hook = 4;
  bool has_pad_hook() const;
  void clear_pad_hook();
  static const int kPadHookFieldNumber = 4;
  const ::GstDebugger::PadHookRequest& pad_hook() const;
  ::GstDebugger::PadHookRequest* mutable_pad_hook();
  ::GstDebugger::PadHookRequest* release_pad_hook();
  void set_allocated_pad_hook(::GstDebugger::PadHookRequest* pad_hook);

  HookTypeCase hook_type_case() const;
  // @@protoc_insertion_point(class_scope:GstDebugger.HookRequest)
 private:
  void set_has_action();
  void clear_has_action();
  void set_has_message();
  void set_has_log();
  void set_has_pad_hook();

  inline bool has_hook_type() const;
  void clear_hook_type();
  inline void clear_has_hook_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int action_;
  union HookTypeUnion {
    HookTypeUnion() {}
    ::GstDebugger::MessageRequest* message_;
    ::GstDebugger::LogRequest* log_;
    ::GstDebugger::PadHookRequest* pad_hook_;
  } hook_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  enum CommandTypeCase {
    kTypeDescription = 1,
    kDebugCategoriesList = 2,
    kHookRequest = 3,
    kLogThreshold = 4,
    kEntireTopology = 5,
    kProperty = 6,
    kPropertySet = 7,
    kPadDynamicInfo = 8,
    COMMAND_TYPE_NOT_SET = 0,
  };

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GstDebugger.TypeDescriptionRequest type_description = 1;
  bool has_type_description() const;
  void clear_type_description();
  static const int kTypeDescriptionFieldNumber = 1;
  const ::GstDebugger::TypeDescriptionRequest& type_description() const;
  ::GstDebugger::TypeDescriptionRequest* mutable_type_description();
  ::GstDebugger::TypeDescriptionRequest* release_type_description();
  void set_allocated_type_description(::GstDebugger::TypeDescriptionRequest* type_description);

  // optional bool debug_categories_list = 2;
  bool has_debug_categories_list() const;
  void clear_debug_categories_list();
  static const int kDebugCategoriesListFieldNumber = 2;
  bool debug_categories_list() const;
  void set_debug_categories_list(bool value);

  // optional .GstDebugger.HookRequest hook_request = 3;
  bool has_hook_request() const;
  void clear_hook_request();
  static const int kHookRequestFieldNumber = 3;
  const ::GstDebugger::HookRequest& hook_request() const;
  ::GstDebugger::HookRequest* mutable_hook_request();
  ::GstDebugger::HookRequest* release_hook_request();
  void set_allocated_hook_request(::GstDebugger::HookRequest* hook_request);

  // optional string log_threshold = 4;
  bool has_log_threshold() const;
  void clear_log_threshold();
  static const int kLogThresholdFieldNumber = 4;
  const ::std::string& log_threshold() const;
  void set_log_threshold(const ::std::string& value);
  #if LANG_CXX11
  void set_log_threshold(::std::string&& value);
  #endif
  void set_log_threshold(const char* value);
  void set_log_threshold(const char* value, size_t size);
  ::std::string* mutable_log_threshold();
  ::std::string* release_log_threshold();
  void set_allocated_log_threshold(::std::string* log_threshold);

  // optional bool entire_topology = 5;
  bool has_entire_topology() const;
  void clear_entire_topology();
  static const int kEntireTopologyFieldNumber = 5;
  bool entire_topology() const;
  void set_entire_topology(bool value);

  // optional .GstDebugger.PropertyRequest property = 6;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 6;
  const ::GstDebugger::PropertyRequest& property() const;
  ::GstDebugger::PropertyRequest* mutable_property();
  ::GstDebugger::PropertyRequest* release_property();
  void set_allocated_property(::GstDebugger::PropertyRequest* property);

  // optional .GstDebugger.PropertyValue property_set = 7;
  bool has_property_set() const;
  void clear_property_set();
  static const int kPropertySetFieldNumber = 7;
  const ::GstDebugger::PropertyValue& property_set() const;
  ::GstDebugger::PropertyValue* mutable_property_set();
  ::GstDebugger::PropertyValue* release_property_set();
  void set_allocated_property_set(::GstDebugger::PropertyValue* property_set);

  // optional string pad_dynamic_info = 8;
  bool has_pad_dynamic_info() const;
  void clear_pad_dynamic_info();
  static const int kPadDynamicInfoFieldNumber = 8;
  const ::std::string& pad_dynamic_info() const;
  void set_pad_dynamic_info(const ::std::string& value);
  #if LANG_CXX11
  void set_pad_dynamic_info(::std::string&& value);
  #endif
  void set_pad_dynamic_info(const char* value);
  void set_pad_dynamic_info(const char* value, size_t size);
  ::std::string* mutable_pad_dynamic_info();
  ::std::string* release_pad_dynamic_info();
  void set_allocated_pad_dynamic_info(::std::string* pad_dynamic_info);

  CommandTypeCase command_type_case() const;
  // @@protoc_insertion_point(class_scope:GstDebugger.Command)
 private:
  void set_has_type_description();
  void set_has_debug_categories_list();
  void set_has_hook_request();
  void set_has_log_threshold();
  void set_has_entire_topology();
  void set_has_property();
  void set_has_property_set();
  void set_has_pad_dynamic_info();

  inline bool has_command_type() const;
  void clear_command_type();
  inline void clear_has_command_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union CommandTypeUnion {
    CommandTypeUnion() {}
    ::GstDebugger::TypeDescriptionRequest* type_description_;
    bool debug_categories_list_;
    ::GstDebugger::HookRequest* hook_request_;
    ::google::protobuf::internal::ArenaStringPtr log_threshold_;
    bool entire_topology_;
    ::GstDebugger::PropertyRequest* property_;
    ::GstDebugger::PropertyValue* property_set_;
    ::google::protobuf::internal::ArenaStringPtr pad_dynamic_info_;
  } command_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugCategories : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.DebugCategories) */ {
 public:
  DebugCategories();
  virtual ~DebugCategories();

  DebugCategories(const DebugCategories& from);

  inline DebugCategories& operator=(const DebugCategories& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugCategories& default_instance();

  static inline const DebugCategories* internal_default_instance() {
    return reinterpret_cast<const DebugCategories*>(
               &_DebugCategories_default_instance_);
  }

  void Swap(DebugCategories* other);

  // implements Message ----------------------------------------------

  inline DebugCategories* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugCategories* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugCategories& from);
  void MergeFrom(const DebugCategories& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugCategories* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string category = 1;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 1;
  const ::std::string& category(int index) const;
  ::std::string* mutable_category(int index);
  void set_category(int index, const ::std::string& value);
  void set_category(int index, const char* value);
  void set_category(int index, const char* value, size_t size);
  ::std::string* add_category();
  void add_category(const ::std::string& value);
  void add_category(const char* value);
  void add_category(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& category() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_category();

  // @@protoc_insertion_point(class_scope:GstDebugger.DebugCategories)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> category_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.LogInfo) */ {
 public:
  LogInfo();
  virtual ~LogInfo();

  LogInfo(const LogInfo& from);

  inline LogInfo& operator=(const LogInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInfo& default_instance();

  static inline const LogInfo* internal_default_instance() {
    return reinterpret_cast<const LogInfo*>(
               &_LogInfo_default_instance_);
  }

  void Swap(LogInfo* other);

  // implements Message ----------------------------------------------

  inline LogInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LogInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogInfo& from);
  void MergeFrom(const LogInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string category = 2;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 2;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // required string file = 3;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 3;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // required string function = 4;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 4;
  const ::std::string& function() const;
  void set_function(const ::std::string& value);
  #if LANG_CXX11
  void set_function(::std::string&& value);
  #endif
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  ::std::string* mutable_function();
  ::std::string* release_function();
  void set_allocated_function(::std::string* function);

  // required string object = 6;
  bool has_object() const;
  void clear_object();
  static const int kObjectFieldNumber = 6;
  const ::std::string& object() const;
  void set_object(const ::std::string& value);
  #if LANG_CXX11
  void set_object(::std::string&& value);
  #endif
  void set_object(const char* value);
  void set_object(const char* value, size_t size);
  ::std::string* mutable_object();
  ::std::string* release_object();
  void set_allocated_object(::std::string* object);

  // required string message = 7;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 7;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 line = 5;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 5;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.LogInfo)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_category();
  void clear_has_category();
  void set_has_file();
  void clear_has_file();
  void set_has_function();
  void clear_has_function();
  void set_has_line();
  void clear_has_line();
  void set_has_object();
  void clear_has_object();
  void set_has_message();
  void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::internal::ArenaStringPtr function_;
  ::google::protobuf::internal::ArenaStringPtr object_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 line_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnumFlagsValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.EnumFlagsValue) */ {
 public:
  EnumFlagsValue();
  virtual ~EnumFlagsValue();

  EnumFlagsValue(const EnumFlagsValue& from);

  inline EnumFlagsValue& operator=(const EnumFlagsValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumFlagsValue& default_instance();

  static inline const EnumFlagsValue* internal_default_instance() {
    return reinterpret_cast<const EnumFlagsValue*>(
               &_EnumFlagsValue_default_instance_);
  }

  void Swap(EnumFlagsValue* other);

  // implements Message ----------------------------------------------

  inline EnumFlagsValue* New() const PROTOBUF_FINAL { return New(NULL); }

  EnumFlagsValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnumFlagsValue& from);
  void MergeFrom(const EnumFlagsValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnumFlagsValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string nick = 3;
  bool has_nick() const;
  void clear_nick();
  static const int kNickFieldNumber = 3;
  const ::std::string& nick() const;
  void set_nick(const ::std::string& value);
  #if LANG_CXX11
  void set_nick(::std::string&& value);
  #endif
  void set_nick(const char* value);
  void set_nick(const char* value, size_t size);
  ::std::string* mutable_nick();
  ::std::string* release_nick();
  void set_allocated_nick(::std::string* nick);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.EnumFlagsValue)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();
  void set_has_nick();
  void clear_has_nick();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr nick_;
  ::google::protobuf::int32 value_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnumFlagsType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.EnumFlagsType) */ {
 public:
  EnumFlagsType();
  virtual ~EnumFlagsType();

  EnumFlagsType(const EnumFlagsType& from);

  inline EnumFlagsType& operator=(const EnumFlagsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumFlagsType& default_instance();

  static inline const EnumFlagsType* internal_default_instance() {
    return reinterpret_cast<const EnumFlagsType*>(
               &_EnumFlagsType_default_instance_);
  }

  void Swap(EnumFlagsType* other);

  // implements Message ----------------------------------------------

  inline EnumFlagsType* New() const PROTOBUF_FINAL { return New(NULL); }

  EnumFlagsType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnumFlagsType& from);
  void MergeFrom(const EnumFlagsType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnumFlagsType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EnumFlagsType_EnumFlagsKind EnumFlagsKind;
  static const EnumFlagsKind ENUM =
    EnumFlagsType_EnumFlagsKind_ENUM;
  static const EnumFlagsKind FLAGS =
    EnumFlagsType_EnumFlagsKind_FLAGS;
  static inline bool EnumFlagsKind_IsValid(int value) {
    return EnumFlagsType_EnumFlagsKind_IsValid(value);
  }
  static const EnumFlagsKind EnumFlagsKind_MIN =
    EnumFlagsType_EnumFlagsKind_EnumFlagsKind_MIN;
  static const EnumFlagsKind EnumFlagsKind_MAX =
    EnumFlagsType_EnumFlagsKind_EnumFlagsKind_MAX;
  static const int EnumFlagsKind_ARRAYSIZE =
    EnumFlagsType_EnumFlagsKind_EnumFlagsKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EnumFlagsKind_descriptor() {
    return EnumFlagsType_EnumFlagsKind_descriptor();
  }
  static inline const ::std::string& EnumFlagsKind_Name(EnumFlagsKind value) {
    return EnumFlagsType_EnumFlagsKind_Name(value);
  }
  static inline bool EnumFlagsKind_Parse(const ::std::string& name,
      EnumFlagsKind* value) {
    return EnumFlagsType_EnumFlagsKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .GstDebugger.EnumFlagsValue values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::GstDebugger::EnumFlagsValue& values(int index) const;
  ::GstDebugger::EnumFlagsValue* mutable_values(int index);
  ::GstDebugger::EnumFlagsValue* add_values();
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::EnumFlagsValue >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::GstDebugger::EnumFlagsValue >&
      values() const;

  // required string type_name = 1;
  bool has_type_name() const;
  void clear_type_name();
  static const int kTypeNameFieldNumber = 1;
  const ::std::string& type_name() const;
  void set_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_type_name(::std::string&& value);
  #endif
  void set_type_name(const char* value);
  void set_type_name(const char* value, size_t size);
  ::std::string* mutable_type_name();
  ::std::string* release_type_name();
  void set_allocated_type_name(::std::string* type_name);

  // required .GstDebugger.EnumFlagsType.EnumFlagsKind kind = 2;
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 2;
  ::GstDebugger::EnumFlagsType_EnumFlagsKind kind() const;
  void set_kind(::GstDebugger::EnumFlagsType_EnumFlagsKind value);

  // @@protoc_insertion_point(class_scope:GstDebugger.EnumFlagsType)
 private:
  void set_has_type_name();
  void clear_has_type_name();
  void set_has_kind();
  void clear_has_kind();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::EnumFlagsValue > values_;
  ::google::protobuf::internal::ArenaStringPtr type_name_;
  int kind_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FactoryMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.FactoryMeta) */ {
 public:
  FactoryMeta();
  virtual ~FactoryMeta();

  FactoryMeta(const FactoryMeta& from);

  inline FactoryMeta& operator=(const FactoryMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FactoryMeta& default_instance();

  static inline const FactoryMeta* internal_default_instance() {
    return reinterpret_cast<const FactoryMeta*>(
               &_FactoryMeta_default_instance_);
  }

  void Swap(FactoryMeta* other);

  // implements Message ----------------------------------------------

  inline FactoryMeta* New() const PROTOBUF_FINAL { return New(NULL); }

  FactoryMeta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FactoryMeta& from);
  void MergeFrom(const FactoryMeta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FactoryMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:GstDebugger.FactoryMeta)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PadTemplate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PadTemplate) */ {
 public:
  PadTemplate();
  virtual ~PadTemplate();

  PadTemplate(const PadTemplate& from);

  inline PadTemplate& operator=(const PadTemplate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PadTemplate& default_instance();

  static inline const PadTemplate* internal_default_instance() {
    return reinterpret_cast<const PadTemplate*>(
               &_PadTemplate_default_instance_);
  }

  void Swap(PadTemplate* other);

  // implements Message ----------------------------------------------

  inline PadTemplate* New() const PROTOBUF_FINAL { return New(NULL); }

  PadTemplate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PadTemplate& from);
  void MergeFrom(const PadTemplate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PadTemplate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_template = 1;
  bool has_name_template() const;
  void clear_name_template();
  static const int kNameTemplateFieldNumber = 1;
  const ::std::string& name_template() const;
  void set_name_template(const ::std::string& value);
  #if LANG_CXX11
  void set_name_template(::std::string&& value);
  #endif
  void set_name_template(const char* value);
  void set_name_template(const char* value, size_t size);
  ::std::string* mutable_name_template();
  ::std::string* release_name_template();
  void set_allocated_name_template(::std::string* name_template);

  // required string caps = 4;
  bool has_caps() const;
  void clear_caps();
  static const int kCapsFieldNumber = 4;
  const ::std::string& caps() const;
  void set_caps(const ::std::string& value);
  #if LANG_CXX11
  void set_caps(::std::string&& value);
  #endif
  void set_caps(const char* value);
  void set_caps(const char* value, size_t size);
  ::std::string* mutable_caps();
  ::std::string* release_caps();
  void set_allocated_caps(::std::string* caps);

  // required int32 direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::google::protobuf::int32 direction() const;
  void set_direction(::google::protobuf::int32 value);

  // required int32 presence = 3;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 3;
  ::google::protobuf::int32 presence() const;
  void set_presence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.PadTemplate)
 private:
  void set_has_name_template();
  void clear_has_name_template();
  void set_has_direction();
  void clear_has_direction();
  void set_has_presence();
  void clear_has_presence();
  void set_has_caps();
  void clear_has_caps();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_template_;
  ::google::protobuf::internal::ArenaStringPtr caps_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 presence_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FactoryType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.FactoryType) */ {
 public:
  FactoryType();
  virtual ~FactoryType();

  FactoryType(const FactoryType& from);

  inline FactoryType& operator=(const FactoryType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FactoryType& default_instance();

  static inline const FactoryType* internal_default_instance() {
    return reinterpret_cast<const FactoryType*>(
               &_FactoryType_default_instance_);
  }

  void Swap(FactoryType* other);

  // implements Message ----------------------------------------------

  inline FactoryType* New() const PROTOBUF_FINAL { return New(NULL); }

  FactoryType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FactoryType& from);
  void MergeFrom(const FactoryType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FactoryType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GstDebugger.FactoryMeta metadata = 2;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::GstDebugger::FactoryMeta& metadata(int index) const;
  ::GstDebugger::FactoryMeta* mutable_metadata(int index);
  ::GstDebugger::FactoryMeta* add_metadata();
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::FactoryMeta >*
      mutable_metadata();
  const ::google::protobuf::RepeatedPtrField< ::GstDebugger::FactoryMeta >&
      metadata() const;

  // repeated .GstDebugger.PadTemplate templates = 3;
  int templates_size() const;
  void clear_templates();
  static const int kTemplatesFieldNumber = 3;
  const ::GstDebugger::PadTemplate& templates(int index) const;
  ::GstDebugger::PadTemplate* mutable_templates(int index);
  ::GstDebugger::PadTemplate* add_templates();
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::PadTemplate >*
      mutable_templates();
  const ::google::protobuf::RepeatedPtrField< ::GstDebugger::PadTemplate >&
      templates() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:GstDebugger.FactoryType)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::FactoryMeta > metadata_;
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::PadTemplate > templates_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ElementKlass : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.ElementKlass) */ {
 public:
  ElementKlass();
  virtual ~ElementKlass();

  ElementKlass(const ElementKlass& from);

  inline ElementKlass& operator=(const ElementKlass& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ElementKlass& default_instance();

  static inline const ElementKlass* internal_default_instance() {
    return reinterpret_cast<const ElementKlass*>(
               &_ElementKlass_default_instance_);
  }

  void Swap(ElementKlass* other);

  // implements Message ----------------------------------------------

  inline ElementKlass* New() const PROTOBUF_FINAL { return New(NULL); }

  ElementKlass* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ElementKlass& from);
  void MergeFrom(const ElementKlass& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ElementKlass* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GstDebugger.PropertyInfo property_info = 2;
  int property_info_size() const;
  void clear_property_info();
  static const int kPropertyInfoFieldNumber = 2;
  const ::GstDebugger::PropertyInfo& property_info(int index) const;
  ::GstDebugger::PropertyInfo* mutable_property_info(int index);
  ::GstDebugger::PropertyInfo* add_property_info();
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::PropertyInfo >*
      mutable_property_info();
  const ::google::protobuf::RepeatedPtrField< ::GstDebugger::PropertyInfo >&
      property_info() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:GstDebugger.ElementKlass)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::GstDebugger::PropertyInfo > property_info_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopologyLink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.TopologyLink) */ {
 public:
  TopologyLink();
  virtual ~TopologyLink();

  TopologyLink(const TopologyLink& from);

  inline TopologyLink& operator=(const TopologyLink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopologyLink& default_instance();

  static inline const TopologyLink* internal_default_instance() {
    return reinterpret_cast<const TopologyLink*>(
               &_TopologyLink_default_instance_);
  }

  void Swap(TopologyLink* other);

  // implements Message ----------------------------------------------

  inline TopologyLink* New() const PROTOBUF_FINAL { return New(NULL); }

  TopologyLink* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopologyLink& from);
  void MergeFrom(const TopologyLink& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopologyLink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_pad = 1;
  bool has_src_pad() const;
  void clear_src_pad();
  static const int kSrcPadFieldNumber = 1;
  const ::std::string& src_pad() const;
  void set_src_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_src_pad(::std::string&& value);
  #endif
  void set_src_pad(const char* value);
  void set_src_pad(const char* value, size_t size);
  ::std::string* mutable_src_pad();
  ::std::string* release_src_pad();
  void set_allocated_src_pad(::std::string* src_pad);

  // required string sink_pad = 2;
  bool has_sink_pad() const;
  void clear_sink_pad();
  static const int kSinkPadFieldNumber = 2;
  const ::std::string& sink_pad() const;
  void set_sink_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_sink_pad(::std::string&& value);
  #endif
  void set_sink_pad(const char* value);
  void set_sink_pad(const char* value, size_t size);
  ::std::string* mutable_sink_pad();
  ::std::string* release_sink_pad();
  void set_allocated_sink_pad(::std::string* sink_pad);

  // @@protoc_insertion_point(class_scope:GstDebugger.TopologyLink)
 private:
  void set_has_src_pad();
  void clear_has_src_pad();
  void set_has_sink_pad();
  void clear_has_sink_pad();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_pad_;
  ::google::protobuf::internal::ArenaStringPtr sink_pad_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopologyElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.TopologyElement) */ {
 public:
  TopologyElement();
  virtual ~TopologyElement();

  TopologyElement(const TopologyElement& from);

  inline TopologyElement& operator=(const TopologyElement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopologyElement& default_instance();

  static inline const TopologyElement* internal_default_instance() {
    return reinterpret_cast<const TopologyElement*>(
               &_TopologyElement_default_instance_);
  }

  void Swap(TopologyElement* other);

  // implements Message ----------------------------------------------

  inline TopologyElement* New() const PROTOBUF_FINAL { return New(NULL); }

  TopologyElement* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopologyElement& from);
  void MergeFrom(const TopologyElement& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopologyElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // required string type_name = 2;
  bool has_type_name() const;
  void clear_type_name();
  static const int kTypeNameFieldNumber = 2;
  const ::std::string& type_name() const;
  void set_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_type_name(::std::string&& value);
  #endif
  void set_type_name(const char* value);
  void set_type_name(const char* value, size_t size);
  ::std::string* mutable_type_name();
  ::std::string* release_type_name();
  void set_allocated_type_name(::std::string* type_name);

  // required string factory_name = 4;
  bool has_factory_name() const;
  void clear_factory_name();
  static const int kFactoryNameFieldNumber = 4;
  const ::std::string& factory_name() const;
  void set_factory_name(const ::std::string& value);
  #if LANG_CXX11
  void set_factory_name(::std::string&& value);
  #endif
  void set_factory_name(const char* value);
  void set_factory_name(const char* value, size_t size);
  ::std::string* mutable_factory_name();
  ::std::string* release_factory_name();
  void set_allocated_factory_name(::std::string* factory_name);

  // required bool is_bin = 3;
  bool has_is_bin() const;
  void clear_is_bin();
  static const int kIsBinFieldNumber = 3;
  bool is_bin() const;
  void set_is_bin(bool value);

  // @@protoc_insertion_point(class_scope:GstDebugger.TopologyElement)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_type_name();
  void clear_has_type_name();
  void set_has_is_bin();
  void clear_has_is_bin();
  void set_has_factory_name();
  void clear_has_factory_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr type_name_;
  ::google::protobuf::internal::ArenaStringPtr factory_name_;
  bool is_bin_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopologyPad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.TopologyPad) */ {
 public:
  TopologyPad();
  virtual ~TopologyPad();

  TopologyPad(const TopologyPad& from);

  inline TopologyPad& operator=(const TopologyPad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopologyPad& default_instance();

  static inline const TopologyPad* internal_default_instance() {
    return reinterpret_cast<const TopologyPad*>(
               &_TopologyPad_default_instance_);
  }

  void Swap(TopologyPad* other);

  // implements Message ----------------------------------------------

  inline TopologyPad* New() const PROTOBUF_FINAL { return New(NULL); }

  TopologyPad* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopologyPad& from);
  void MergeFrom(const TopologyPad& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopologyPad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional .GstDebugger.PadTemplate template = 5;
  bool has_template_() const;
  void clear_template_();
  static const int kTemplateFieldNumber = 5;
  const ::GstDebugger::PadTemplate& template_() const;
  ::GstDebugger::PadTemplate* mutable_template_();
  ::GstDebugger::PadTemplate* release_template_();
  void set_allocated_template_(::GstDebugger::PadTemplate* template_);

  // required bool is_ghostpad = 2;
  bool has_is_ghostpad() const;
  void clear_is_ghostpad();
  static const int kIsGhostpadFieldNumber = 2;
  bool is_ghostpad() const;
  void set_is_ghostpad(bool value);

  // required int32 direction = 3;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 3;
  ::google::protobuf::int32 direction() const;
  void set_direction(::google::protobuf::int32 value);

  // required int32 presence = 4;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 4;
  ::google::protobuf::int32 presence() const;
  void set_presence(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GstDebugger.TopologyPad)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_is_ghostpad();
  void clear_has_is_ghostpad();
  void set_has_direction();
  void clear_has_direction();
  void set_has_presence();
  void clear_has_presence();
  void set_has_template_();
  void clear_has_template_();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::GstDebugger::PadTemplate* template__;
  bool is_ghostpad_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 presence_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopologyInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.TopologyInfo) */ {
 public:
  TopologyInfo();
  virtual ~TopologyInfo();

  TopologyInfo(const TopologyInfo& from);

  inline TopologyInfo& operator=(const TopologyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopologyInfo& default_instance();

  enum TopologyTypeCase {
    kLink = 2,
    kElement = 3,
    kPad = 4,
    TOPOLOGY_TYPE_NOT_SET = 0,
  };

  static inline const TopologyInfo* internal_default_instance() {
    return reinterpret_cast<const TopologyInfo*>(
               &_TopologyInfo_default_instance_);
  }

  void Swap(TopologyInfo* other);

  // implements Message ----------------------------------------------

  inline TopologyInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TopologyInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopologyInfo& from);
  void MergeFrom(const TopologyInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopologyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .GstDebugger.Action action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::GstDebugger::Action action() const;
  void set_action(::GstDebugger::Action value);

  // optional .GstDebugger.TopologyLink link = 2;
  bool has_link() const;
  void clear_link();
  static const int kLinkFieldNumber = 2;
  const ::GstDebugger::TopologyLink& link() const;
  ::GstDebugger::TopologyLink* mutable_link();
  ::GstDebugger::TopologyLink* release_link();
  void set_allocated_link(::GstDebugger::TopologyLink* link);

  // optional .GstDebugger.TopologyElement element = 3;
  bool has_element() const;
  void clear_element();
  static const int kElementFieldNumber = 3;
  const ::GstDebugger::TopologyElement& element() const;
  ::GstDebugger::TopologyElement* mutable_element();
  ::GstDebugger::TopologyElement* release_element();
  void set_allocated_element(::GstDebugger::TopologyElement* element);

  // optional .GstDebugger.TopologyPad pad = 4;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 4;
  const ::GstDebugger::TopologyPad& pad() const;
  ::GstDebugger::TopologyPad* mutable_pad();
  ::GstDebugger::TopologyPad* release_pad();
  void set_allocated_pad(::GstDebugger::TopologyPad* pad);

  TopologyTypeCase topology_type_case() const;
  // @@protoc_insertion_point(class_scope:GstDebugger.TopologyInfo)
 private:
  void set_has_action();
  void clear_has_action();
  void set_has_link();
  void set_has_element();
  void set_has_pad();

  inline bool has_topology_type() const;
  void clear_topology_type();
  inline void clear_has_topology_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int action_;
  union TopologyTypeUnion {
    TopologyTypeUnion() {}
    ::GstDebugger::TopologyLink* link_;
    ::GstDebugger::TopologyElement* element_;
    ::GstDebugger::TopologyPad* pad_;
  } topology_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PadDynamicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.PadDynamicInfo) */ {
 public:
  PadDynamicInfo();
  virtual ~PadDynamicInfo();

  PadDynamicInfo(const PadDynamicInfo& from);

  inline PadDynamicInfo& operator=(const PadDynamicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PadDynamicInfo& default_instance();

  static inline const PadDynamicInfo* internal_default_instance() {
    return reinterpret_cast<const PadDynamicInfo*>(
               &_PadDynamicInfo_default_instance_);
  }

  void Swap(PadDynamicInfo* other);

  // implements Message ----------------------------------------------

  inline PadDynamicInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PadDynamicInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PadDynamicInfo& from);
  void MergeFrom(const PadDynamicInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PadDynamicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string allowed_caps = 1;
  bool has_allowed_caps() const;
  void clear_allowed_caps();
  static const int kAllowedCapsFieldNumber = 1;
  const ::std::string& allowed_caps() const;
  void set_allowed_caps(const ::std::string& value);
  #if LANG_CXX11
  void set_allowed_caps(::std::string&& value);
  #endif
  void set_allowed_caps(const char* value);
  void set_allowed_caps(const char* value, size_t size);
  ::std::string* mutable_allowed_caps();
  ::std::string* release_allowed_caps();
  void set_allocated_allowed_caps(::std::string* allowed_caps);

  // required string current_caps = 2;
  bool has_current_caps() const;
  void clear_current_caps();
  static const int kCurrentCapsFieldNumber = 2;
  const ::std::string& current_caps() const;
  void set_current_caps(const ::std::string& value);
  #if LANG_CXX11
  void set_current_caps(::std::string&& value);
  #endif
  void set_current_caps(const char* value);
  void set_current_caps(const char* value, size_t size);
  ::std::string* mutable_current_caps();
  ::std::string* release_current_caps();
  void set_allocated_current_caps(::std::string* current_caps);

  // required string pad = 3;
  bool has_pad() const;
  void clear_pad();
  static const int kPadFieldNumber = 3;
  const ::std::string& pad() const;
  void set_pad(const ::std::string& value);
  #if LANG_CXX11
  void set_pad(::std::string&& value);
  #endif
  void set_pad(const char* value);
  void set_pad(const char* value, size_t size);
  ::std::string* mutable_pad();
  ::std::string* release_pad();
  void set_allocated_pad(::std::string* pad);

  // @@protoc_insertion_point(class_scope:GstDebugger.PadDynamicInfo)
 private:
  void set_has_allowed_caps();
  void clear_has_allowed_caps();
  void set_has_current_caps();
  void clear_has_current_caps();
  void set_has_pad();
  void clear_has_pad();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr allowed_caps_;
  ::google::protobuf::internal::ArenaStringPtr current_caps_;
  ::google::protobuf::internal::ArenaStringPtr pad_;
  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GStreamerData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GstDebugger.GStreamerData) */ {
 public:
  GStreamerData();
  virtual ~GStreamerData();

  GStreamerData(const GStreamerData& from);

  inline GStreamerData& operator=(const GStreamerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GStreamerData& default_instance();

  enum InfoTypeCase {
    kDebugCategories = 1,
    kLogInfo = 2,
    kEnumFlagsType = 3,
    kFactory = 4,
    kMessageInfo = 5,
    kConfirmation = 6,
    kEventInfo = 7,
    kTopologyInfo = 8,
    kQueryInfo = 9,
    kPropertyValue = 10,
    kElementKlass = 11,
    kBufferInfo = 12,
    kPadDynamicInfo = 13,
    INFO_TYPE_NOT_SET = 0,
  };

  static inline const GStreamerData* internal_default_instance() {
    return reinterpret_cast<const GStreamerData*>(
               &_GStreamerData_default_instance_);
  }

  void Swap(GStreamerData* other);

  // implements Message ----------------------------------------------

  inline GStreamerData* New() const PROTOBUF_FINAL { return New(NULL); }

  GStreamerData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GStreamerData& from);
  void MergeFrom(const GStreamerData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GStreamerData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .GstDebugger.DebugCategories debug_categories = 1;
  bool has_debug_categories() const;
  void clear_debug_categories();
  static const int kDebugCategoriesFieldNumber = 1;
  const ::GstDebugger::DebugCategories& debug_categories() const;
  ::GstDebugger::DebugCategories* mutable_debug_categories();
  ::GstDebugger::DebugCategories* release_debug_categories();
  void set_allocated_debug_categories(::GstDebugger::DebugCategories* debug_categories);

  // optional .GstDebugger.LogInfo log_info = 2;
  bool has_log_info() const;
  void clear_log_info();
  static const int kLogInfoFieldNumber = 2;
  const ::GstDebugger::LogInfo& log_info() const;
  ::GstDebugger::LogInfo* mutable_log_info();
  ::GstDebugger::LogInfo* release_log_info();
  void set_allocated_log_info(::GstDebugger::LogInfo* log_info);

  // optional .GstDebugger.EnumFlagsType enum_flags_type = 3;
  bool has_enum_flags_type() const;
  void clear_enum_flags_type();
  static const int kEnumFlagsTypeFieldNumber = 3;
  const ::GstDebugger::EnumFlagsType& enum_flags_type() const;
  ::GstDebugger::EnumFlagsType* mutable_enum_flags_type();
  ::GstDebugger::EnumFlagsType* release_enum_flags_type();
  void set_allocated_enum_flags_type(::GstDebugger::EnumFlagsType* enum_flags_type);

  // optional .GstDebugger.FactoryType factory = 4;
  bool has_factory() const;
  void clear_factory();
  static const int kFactoryFieldNumber = 4;
  const ::GstDebugger::FactoryType& factory() const;
  ::GstDebugger::FactoryType* mutable_factory();
  ::GstDebugger::FactoryType* release_factory();
  void set_allocated_factory(::GstDebugger::FactoryType* factory);

  // optional .GstDebugger.MessageInfo message_info = 5;
  bool has_message_info() const;
  void clear_message_info();
  static const int kMessageInfoFieldNumber = 5;
  const ::GstDebugger::MessageInfo& message_info() const;
  ::GstDebugger::MessageInfo* mutable_message_info();
  ::GstDebugger::MessageInfo* release_message_info();
  void set_allocated_message_info(::GstDebugger::MessageInfo* message_info);

  // optional .GstDebugger.Command confirmation = 6;
  bool has_confirmation() const;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 6;
  const ::GstDebugger::Command& confirmation() const;
  ::GstDebugger::Command* mutable_confirmation();
  ::GstDebugger::Command* release_confirmation();
  void set_allocated_confirmation(::GstDebugger::Command* confirmation);

  // optional .GstDebugger.EventInfo event_info = 7;
  bool has_event_info() const;
  void clear_event_info();
  static const int kEventInfoFieldNumber = 7;
  const ::GstDebugger::EventInfo& event_info() const;
  ::GstDebugger::EventInfo* mutable_event_info();
  ::GstDebugger::EventInfo* release_event_info();
  void set_allocated_event_info(::GstDebugger::EventInfo* event_info);

  // optional .GstDebugger.TopologyInfo topology_info = 8;
  bool has_topology_info() const;
  void clear_topology_info();
  static const int kTopologyInfoFieldNumber = 8;
  const ::GstDebugger::TopologyInfo& topology_info() const;
  ::GstDebugger::TopologyInfo* mutable_topology_info();
  ::GstDebugger::TopologyInfo* release_topology_info();
  void set_allocated_topology_info(::GstDebugger::TopologyInfo* topology_info);

  // optional .GstDebugger.QueryInfo query_info = 9;
  bool has_query_info() const;
  void clear_query_info();
  static const int kQueryInfoFieldNumber = 9;
  const ::GstDebugger::QueryInfo& query_info() const;
  ::GstDebugger::QueryInfo* mutable_query_info();
  ::GstDebugger::QueryInfo* release_query_info();
  void set_allocated_query_info(::GstDebugger::QueryInfo* query_info);

  // optional .GstDebugger.PropertyValue property_value = 10;
  bool has_property_value() const;
  void clear_property_value();
  static const int kPropertyValueFieldNumber = 10;
  const ::GstDebugger::PropertyValue& property_value() const;
  ::GstDebugger::PropertyValue* mutable_property_value();
  ::GstDebugger::PropertyValue* release_property_value();
  void set_allocated_property_value(::GstDebugger::PropertyValue* property_value);

  // optional .GstDebugger.ElementKlass element_klass = 11;
  bool has_element_klass() const;
  void clear_element_klass();
  static const int kElementKlassFieldNumber = 11;
  const ::GstDebugger::ElementKlass& element_klass() const;
  ::GstDebugger::ElementKlass* mutable_element_klass();
  ::GstDebugger::ElementKlass* release_element_klass();
  void set_allocated_element_klass(::GstDebugger::ElementKlass* element_klass);

  // optional .GstDebugger.BufferInfo buffer_info = 12;
  bool has_buffer_info() const;
  void clear_buffer_info();
  static const int kBufferInfoFieldNumber = 12;
  const ::GstDebugger::BufferInfo& buffer_info() const;
  ::GstDebugger::BufferInfo* mutable_buffer_info();
  ::GstDebugger::BufferInfo* release_buffer_info();
  void set_allocated_buffer_info(::GstDebugger::BufferInfo* buffer_info);

  // optional .GstDebugger.PadDynamicInfo pad_dynamic_info = 13;
  bool has_pad_dynamic_info() const;
  void clear_pad_dynamic_info();
  static const int kPadDynamicInfoFieldNumber = 13;
  const ::GstDebugger::PadDynamicInfo& pad_dynamic_info() const;
  ::GstDebugger::PadDynamicInfo* mutable_pad_dynamic_info();
  ::GstDebugger::PadDynamicInfo* release_pad_dynamic_info();
  void set_allocated_pad_dynamic_info(::GstDebugger::PadDynamicInfo* pad_dynamic_info);

  InfoTypeCase info_type_case() const;
  // @@protoc_insertion_point(class_scope:GstDebugger.GStreamerData)
 private:
  void set_has_debug_categories();
  void set_has_log_info();
  void set_has_enum_flags_type();
  void set_has_factory();
  void set_has_message_info();
  void set_has_confirmation();
  void set_has_event_info();
  void set_has_topology_info();
  void set_has_query_info();
  void set_has_property_value();
  void set_has_element_klass();
  void set_has_buffer_info();
  void set_has_pad_dynamic_info();

  inline bool has_info_type() const;
  void clear_info_type();
  inline void clear_has_info_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union InfoTypeUnion {
    InfoTypeUnion() {}
    ::GstDebugger::DebugCategories* debug_categories_;
    ::GstDebugger::LogInfo* log_info_;
    ::GstDebugger::EnumFlagsType* enum_flags_type_;
    ::GstDebugger::FactoryType* factory_;
    ::GstDebugger::MessageInfo* message_info_;
    ::GstDebugger::Command* confirmation_;
    ::GstDebugger::EventInfo* event_info_;
    ::GstDebugger::TopologyInfo* topology_info_;
    ::GstDebugger::QueryInfo* query_info_;
    ::GstDebugger::PropertyValue* property_value_;
    ::GstDebugger::ElementKlass* element_klass_;
    ::GstDebugger::BufferInfo* buffer_info_;
    ::GstDebugger::PadDynamicInfo* pad_dynamic_info_;
  } info_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_gstdebugger_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Value

// required uint64 gtype = 1;
inline bool Value::has_gtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_gtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_gtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_gtype() {
  gtype_ = GOOGLE_ULONGLONG(0);
  clear_has_gtype();
}
inline ::google::protobuf::uint64 Value::gtype() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Value.gtype)
  return gtype_;
}
inline void Value::set_gtype(::google::protobuf::uint64 value) {
  set_has_gtype();
  gtype_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.Value.gtype)
}

// optional int32 internal_type = 2;
inline bool Value::has_internal_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Value::set_has_internal_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Value::clear_has_internal_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Value::clear_internal_type() {
  internal_type_ = 0;
  clear_has_internal_type();
}
inline ::google::protobuf::int32 Value::internal_type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Value.internal_type)
  return internal_type_;
}
inline void Value::set_internal_type(::google::protobuf::int32 value) {
  set_has_internal_type();
  internal_type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.Value.internal_type)
}

// required bytes data = 3;
inline bool Value::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Value::data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Value.data)
  return data_.GetNoArena();
}
inline void Value::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.Value.data)
}
#if LANG_CXX11
inline void Value::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.Value.data)
}
#endif
inline void Value::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.Value.data)
}
inline void Value::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.Value.data)
}
inline ::std::string* Value::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:GstDebugger.Value.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_data() {
  // @@protoc_insertion_point(field_release:GstDebugger.Value.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Value.data)
}

// required string type_name = 4;
inline bool Value::has_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
inline const ::std::string& Value::type_name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Value.type_name)
  return type_name_.GetNoArena();
}
inline void Value::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.Value.type_name)
}
#if LANG_CXX11
inline void Value::set_type_name(::std::string&& value) {
  set_has_type_name();
  type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.Value.type_name)
}
#endif
inline void Value::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.Value.type_name)
}
inline void Value::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.Value.type_name)
}
inline ::std::string* Value::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.Value.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_type_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.Value.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Value.type_name)
}

// -------------------------------------------------------------------

// PropertyInfo

// required string name = 1;
inline bool PropertyInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PropertyInfo::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyInfo.name)
  return name_.GetNoArena();
}
inline void PropertyInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyInfo.name)
}
#if LANG_CXX11
inline void PropertyInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyInfo.name)
}
#endif
inline void PropertyInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyInfo.name)
}
inline void PropertyInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyInfo.name)
}
inline ::std::string* PropertyInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyInfo::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyInfo.name)
}

// required string nick = 2;
inline bool PropertyInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyInfo::clear_nick() {
  nick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick();
}
inline const ::std::string& PropertyInfo::nick() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyInfo.nick)
  return nick_.GetNoArena();
}
inline void PropertyInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyInfo.nick)
}
#if LANG_CXX11
inline void PropertyInfo::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyInfo.nick)
}
#endif
inline void PropertyInfo::set_nick(const char* value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyInfo.nick)
}
inline void PropertyInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyInfo.nick)
}
inline ::std::string* PropertyInfo::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyInfo.nick)
  return nick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyInfo::release_nick() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyInfo.nick)
  clear_has_nick();
  return nick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyInfo::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyInfo.nick)
}

// required string blurb = 3;
inline bool PropertyInfo::has_blurb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyInfo::set_has_blurb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyInfo::clear_has_blurb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyInfo::clear_blurb() {
  blurb_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blurb();
}
inline const ::std::string& PropertyInfo::blurb() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyInfo.blurb)
  return blurb_.GetNoArena();
}
inline void PropertyInfo::set_blurb(const ::std::string& value) {
  set_has_blurb();
  blurb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyInfo.blurb)
}
#if LANG_CXX11
inline void PropertyInfo::set_blurb(::std::string&& value) {
  set_has_blurb();
  blurb_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyInfo.blurb)
}
#endif
inline void PropertyInfo::set_blurb(const char* value) {
  set_has_blurb();
  blurb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyInfo.blurb)
}
inline void PropertyInfo::set_blurb(const char* value, size_t size) {
  set_has_blurb();
  blurb_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyInfo.blurb)
}
inline ::std::string* PropertyInfo::mutable_blurb() {
  set_has_blurb();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyInfo.blurb)
  return blurb_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyInfo::release_blurb() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyInfo.blurb)
  clear_has_blurb();
  return blurb_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyInfo::set_allocated_blurb(::std::string* blurb) {
  if (blurb != NULL) {
    set_has_blurb();
  } else {
    clear_has_blurb();
  }
  blurb_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blurb);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyInfo.blurb)
}

// required int32 flags = 4;
inline bool PropertyInfo::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyInfo::set_has_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PropertyInfo::clear_has_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PropertyInfo::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 PropertyInfo::flags() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyInfo.flags)
  return flags_;
}
inline void PropertyInfo::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyInfo.flags)
}

// required .GstDebugger.Value default_value = 5;
inline bool PropertyInfo::has_default_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyInfo::set_has_default_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PropertyInfo::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PropertyInfo::clear_default_value() {
  if (default_value_ != NULL) default_value_->::GstDebugger::Value::Clear();
  clear_has_default_value();
}
inline const ::GstDebugger::Value& PropertyInfo::default_value() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyInfo.default_value)
  return default_value_ != NULL ? *default_value_
                         : *::GstDebugger::Value::internal_default_instance();
}
inline ::GstDebugger::Value* PropertyInfo::mutable_default_value() {
  set_has_default_value();
  if (default_value_ == NULL) {
    default_value_ = new ::GstDebugger::Value;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyInfo.default_value)
  return default_value_;
}
inline ::GstDebugger::Value* PropertyInfo::release_default_value() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyInfo.default_value)
  clear_has_default_value();
  ::GstDebugger::Value* temp = default_value_;
  default_value_ = NULL;
  return temp;
}
inline void PropertyInfo::set_allocated_default_value(::GstDebugger::Value* default_value) {
  delete default_value_;
  default_value_ = default_value;
  if (default_value) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyInfo.default_value)
}

// -------------------------------------------------------------------

// PropertyValue

// required string name = 1;
inline bool PropertyValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PropertyValue::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyValue.name)
  return name_.GetNoArena();
}
inline void PropertyValue::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyValue.name)
}
#if LANG_CXX11
inline void PropertyValue::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyValue.name)
}
#endif
inline void PropertyValue::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyValue.name)
}
inline void PropertyValue::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyValue.name)
}
inline ::std::string* PropertyValue::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyValue::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyValue.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyValue.name)
}

// required string object = 2;
inline bool PropertyValue::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyValue::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyValue::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyValue::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& PropertyValue::object() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyValue.object)
  return object_.GetNoArena();
}
inline void PropertyValue::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyValue.object)
}
#if LANG_CXX11
inline void PropertyValue::set_object(::std::string&& value) {
  set_has_object();
  object_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyValue.object)
}
#endif
inline void PropertyValue::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyValue.object)
}
inline void PropertyValue::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyValue.object)
}
inline ::std::string* PropertyValue::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyValue.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyValue::release_object() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyValue.object)
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyValue::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyValue.object)
}

// required .GstDebugger.Value value = 3;
inline bool PropertyValue::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyValue::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PropertyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PropertyValue::clear_value() {
  if (value_ != NULL) value_->::GstDebugger::Value::Clear();
  clear_has_value();
}
inline const ::GstDebugger::Value& PropertyValue::value() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyValue.value)
  return value_ != NULL ? *value_
                         : *::GstDebugger::Value::internal_default_instance();
}
inline ::GstDebugger::Value* PropertyValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::GstDebugger::Value;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyValue.value)
  return value_;
}
inline ::GstDebugger::Value* PropertyValue::release_value() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyValue.value)
  clear_has_value();
  ::GstDebugger::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PropertyValue::set_allocated_value(::GstDebugger::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyValue.value)
}

// -------------------------------------------------------------------

// PropertyRequest

// optional string name = 1;
inline bool PropertyRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PropertyRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PropertyRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PropertyRequest::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyRequest.name)
  return name_.GetNoArena();
}
inline void PropertyRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyRequest.name)
}
#if LANG_CXX11
inline void PropertyRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyRequest.name)
}
#endif
inline void PropertyRequest::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyRequest.name)
}
inline void PropertyRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyRequest.name)
}
inline ::std::string* PropertyRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyRequest::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyRequest.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyRequest.name)
}

// required string object = 2;
inline bool PropertyRequest::has_object() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyRequest::set_has_object() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PropertyRequest::clear_has_object() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PropertyRequest::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& PropertyRequest::object() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PropertyRequest.object)
  return object_.GetNoArena();
}
inline void PropertyRequest::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PropertyRequest.object)
}
#if LANG_CXX11
inline void PropertyRequest::set_object(::std::string&& value) {
  set_has_object();
  object_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PropertyRequest.object)
}
#endif
inline void PropertyRequest::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PropertyRequest.object)
}
inline void PropertyRequest::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PropertyRequest.object)
}
inline ::std::string* PropertyRequest::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PropertyRequest.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PropertyRequest::release_object() {
  // @@protoc_insertion_point(field_release:GstDebugger.PropertyRequest.object)
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PropertyRequest::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PropertyRequest.object)
}

// -------------------------------------------------------------------

// MessageInfo

// required int32 type = 1;
inline bool MessageInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MessageInfo::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageInfo.type)
  return type_;
}
inline void MessageInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.MessageInfo.type)
}

// required uint64 timestamp = 2;
inline bool MessageInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageInfo::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 MessageInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageInfo.timestamp)
  return timestamp_;
}
inline void MessageInfo::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.MessageInfo.timestamp)
}

// required string source = 3;
inline bool MessageInfo::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInfo::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& MessageInfo::source() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageInfo.source)
  return source_.GetNoArena();
}
inline void MessageInfo::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.MessageInfo.source)
}
#if LANG_CXX11
inline void MessageInfo::set_source(::std::string&& value) {
  set_has_source();
  source_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.MessageInfo.source)
}
#endif
inline void MessageInfo::set_source(const char* value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.MessageInfo.source)
}
inline void MessageInfo::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.MessageInfo.source)
}
inline ::std::string* MessageInfo::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:GstDebugger.MessageInfo.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageInfo::release_source() {
  // @@protoc_insertion_point(field_release:GstDebugger.MessageInfo.source)
  clear_has_source();
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.MessageInfo.source)
}

// required uint32 seqnum = 4;
inline bool MessageInfo::has_seqnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageInfo::set_has_seqnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageInfo::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageInfo::clear_seqnum() {
  seqnum_ = 0u;
  clear_has_seqnum();
}
inline ::google::protobuf::uint32 MessageInfo::seqnum() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageInfo.seqnum)
  return seqnum_;
}
inline void MessageInfo::set_seqnum(::google::protobuf::uint32 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.MessageInfo.seqnum)
}

// required bytes structure_data = 5;
inline bool MessageInfo::has_structure_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageInfo::set_has_structure_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageInfo::clear_has_structure_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageInfo::clear_structure_data() {
  structure_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_structure_data();
}
inline const ::std::string& MessageInfo::structure_data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageInfo.structure_data)
  return structure_data_.GetNoArena();
}
inline void MessageInfo::set_structure_data(const ::std::string& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.MessageInfo.structure_data)
}
#if LANG_CXX11
inline void MessageInfo::set_structure_data(::std::string&& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.MessageInfo.structure_data)
}
#endif
inline void MessageInfo::set_structure_data(const char* value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.MessageInfo.structure_data)
}
inline void MessageInfo::set_structure_data(const void* value, size_t size) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.MessageInfo.structure_data)
}
inline ::std::string* MessageInfo::mutable_structure_data() {
  set_has_structure_data();
  // @@protoc_insertion_point(field_mutable:GstDebugger.MessageInfo.structure_data)
  return structure_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageInfo::release_structure_data() {
  // @@protoc_insertion_point(field_release:GstDebugger.MessageInfo.structure_data)
  clear_has_structure_data();
  return structure_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageInfo::set_allocated_structure_data(::std::string* structure_data) {
  if (structure_data != NULL) {
    set_has_structure_data();
  } else {
    clear_has_structure_data();
  }
  structure_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), structure_data);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.MessageInfo.structure_data)
}

// -------------------------------------------------------------------

// EventInfo

// required int32 type = 1;
inline bool EventInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 EventInfo::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventInfo.type)
  return type_;
}
inline void EventInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EventInfo.type)
}

// required uint64 timestamp = 2;
inline bool EventInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventInfo::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 EventInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventInfo.timestamp)
  return timestamp_;
}
inline void EventInfo::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EventInfo.timestamp)
}

// required uint32 seqnum = 3;
inline bool EventInfo::has_seqnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventInfo::set_has_seqnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventInfo::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventInfo::clear_seqnum() {
  seqnum_ = 0u;
  clear_has_seqnum();
}
inline ::google::protobuf::uint32 EventInfo::seqnum() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventInfo.seqnum)
  return seqnum_;
}
inline void EventInfo::set_seqnum(::google::protobuf::uint32 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EventInfo.seqnum)
}

// required string pad = 4;
inline bool EventInfo::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventInfo::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventInfo::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventInfo::clear_pad() {
  pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pad();
}
inline const ::std::string& EventInfo::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventInfo.pad)
  return pad_.GetNoArena();
}
inline void EventInfo::set_pad(const ::std::string& value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.EventInfo.pad)
}
#if LANG_CXX11
inline void EventInfo::set_pad(::std::string&& value) {
  set_has_pad();
  pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.EventInfo.pad)
}
#endif
inline void EventInfo::set_pad(const char* value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.EventInfo.pad)
}
inline void EventInfo::set_pad(const char* value, size_t size) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.EventInfo.pad)
}
inline ::std::string* EventInfo::mutable_pad() {
  set_has_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.EventInfo.pad)
  return pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventInfo::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.EventInfo.pad)
  clear_has_pad();
  return pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventInfo::set_allocated_pad(::std::string* pad) {
  if (pad != NULL) {
    set_has_pad();
  } else {
    clear_has_pad();
  }
  pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.EventInfo.pad)
}

// required bytes structure_data = 5;
inline bool EventInfo::has_structure_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventInfo::set_has_structure_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventInfo::clear_has_structure_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventInfo::clear_structure_data() {
  structure_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_structure_data();
}
inline const ::std::string& EventInfo::structure_data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventInfo.structure_data)
  return structure_data_.GetNoArena();
}
inline void EventInfo::set_structure_data(const ::std::string& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.EventInfo.structure_data)
}
#if LANG_CXX11
inline void EventInfo::set_structure_data(::std::string&& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.EventInfo.structure_data)
}
#endif
inline void EventInfo::set_structure_data(const char* value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.EventInfo.structure_data)
}
inline void EventInfo::set_structure_data(const void* value, size_t size) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.EventInfo.structure_data)
}
inline ::std::string* EventInfo::mutable_structure_data() {
  set_has_structure_data();
  // @@protoc_insertion_point(field_mutable:GstDebugger.EventInfo.structure_data)
  return structure_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EventInfo::release_structure_data() {
  // @@protoc_insertion_point(field_release:GstDebugger.EventInfo.structure_data)
  clear_has_structure_data();
  return structure_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EventInfo::set_allocated_structure_data(::std::string* structure_data) {
  if (structure_data != NULL) {
    set_has_structure_data();
  } else {
    clear_has_structure_data();
  }
  structure_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), structure_data);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.EventInfo.structure_data)
}

// -------------------------------------------------------------------

// QueryInfo

// required int32 type = 1;
inline bool QueryInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 QueryInfo::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.QueryInfo.type)
  return type_;
}
inline void QueryInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.QueryInfo.type)
}

// required string pad = 2;
inline bool QueryInfo::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryInfo::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryInfo::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryInfo::clear_pad() {
  pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pad();
}
inline const ::std::string& QueryInfo::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.QueryInfo.pad)
  return pad_.GetNoArena();
}
inline void QueryInfo::set_pad(const ::std::string& value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.QueryInfo.pad)
}
#if LANG_CXX11
inline void QueryInfo::set_pad(::std::string&& value) {
  set_has_pad();
  pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.QueryInfo.pad)
}
#endif
inline void QueryInfo::set_pad(const char* value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.QueryInfo.pad)
}
inline void QueryInfo::set_pad(const char* value, size_t size) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.QueryInfo.pad)
}
inline ::std::string* QueryInfo::mutable_pad() {
  set_has_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.QueryInfo.pad)
  return pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryInfo::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.QueryInfo.pad)
  clear_has_pad();
  return pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_pad(::std::string* pad) {
  if (pad != NULL) {
    set_has_pad();
  } else {
    clear_has_pad();
  }
  pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.QueryInfo.pad)
}

// required bytes structure_data = 3;
inline bool QueryInfo::has_structure_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryInfo::set_has_structure_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryInfo::clear_has_structure_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryInfo::clear_structure_data() {
  structure_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_structure_data();
}
inline const ::std::string& QueryInfo::structure_data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.QueryInfo.structure_data)
  return structure_data_.GetNoArena();
}
inline void QueryInfo::set_structure_data(const ::std::string& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.QueryInfo.structure_data)
}
#if LANG_CXX11
inline void QueryInfo::set_structure_data(::std::string&& value) {
  set_has_structure_data();
  structure_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.QueryInfo.structure_data)
}
#endif
inline void QueryInfo::set_structure_data(const char* value) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.QueryInfo.structure_data)
}
inline void QueryInfo::set_structure_data(const void* value, size_t size) {
  set_has_structure_data();
  structure_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.QueryInfo.structure_data)
}
inline ::std::string* QueryInfo::mutable_structure_data() {
  set_has_structure_data();
  // @@protoc_insertion_point(field_mutable:GstDebugger.QueryInfo.structure_data)
  return structure_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* QueryInfo::release_structure_data() {
  // @@protoc_insertion_point(field_release:GstDebugger.QueryInfo.structure_data)
  clear_has_structure_data();
  return structure_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void QueryInfo::set_allocated_structure_data(::std::string* structure_data) {
  if (structure_data != NULL) {
    set_has_structure_data();
  } else {
    clear_has_structure_data();
  }
  structure_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), structure_data);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.QueryInfo.structure_data)
}

// -------------------------------------------------------------------

// BufferInfo

// required uint64 pts = 1;
inline bool BufferInfo::has_pts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BufferInfo::set_has_pts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BufferInfo::clear_has_pts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BufferInfo::clear_pts() {
  pts_ = GOOGLE_ULONGLONG(0);
  clear_has_pts();
}
inline ::google::protobuf::uint64 BufferInfo::pts() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.pts)
  return pts_;
}
inline void BufferInfo::set_pts(::google::protobuf::uint64 value) {
  set_has_pts();
  pts_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.pts)
}

// required uint64 dts = 2;
inline bool BufferInfo::has_dts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BufferInfo::set_has_dts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BufferInfo::clear_has_dts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BufferInfo::clear_dts() {
  dts_ = GOOGLE_ULONGLONG(0);
  clear_has_dts();
}
inline ::google::protobuf::uint64 BufferInfo::dts() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.dts)
  return dts_;
}
inline void BufferInfo::set_dts(::google::protobuf::uint64 value) {
  set_has_dts();
  dts_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.dts)
}

// required uint64 duration = 3;
inline bool BufferInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BufferInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BufferInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BufferInfo::clear_duration() {
  duration_ = GOOGLE_ULONGLONG(0);
  clear_has_duration();
}
inline ::google::protobuf::uint64 BufferInfo::duration() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.duration)
  return duration_;
}
inline void BufferInfo::set_duration(::google::protobuf::uint64 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.duration)
}

// required uint64 offset = 4;
inline bool BufferInfo::has_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BufferInfo::set_has_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BufferInfo::clear_has_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BufferInfo::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 BufferInfo::offset() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.offset)
  return offset_;
}
inline void BufferInfo::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.offset)
}

// required uint64 offset_end = 5;
inline bool BufferInfo::has_offset_end() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BufferInfo::set_has_offset_end() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BufferInfo::clear_has_offset_end() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BufferInfo::clear_offset_end() {
  offset_end_ = GOOGLE_ULONGLONG(0);
  clear_has_offset_end();
}
inline ::google::protobuf::uint64 BufferInfo::offset_end() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.offset_end)
  return offset_end_;
}
inline void BufferInfo::set_offset_end(::google::protobuf::uint64 value) {
  set_has_offset_end();
  offset_end_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.offset_end)
}

// required uint64 size = 6;
inline bool BufferInfo::has_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BufferInfo::set_has_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BufferInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BufferInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 BufferInfo::size() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.size)
  return size_;
}
inline void BufferInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.size)
}

// required string pad = 7;
inline bool BufferInfo::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BufferInfo::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BufferInfo::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BufferInfo::clear_pad() {
  pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pad();
}
inline const ::std::string& BufferInfo::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.pad)
  return pad_.GetNoArena();
}
inline void BufferInfo::set_pad(const ::std::string& value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.pad)
}
#if LANG_CXX11
inline void BufferInfo::set_pad(::std::string&& value) {
  set_has_pad();
  pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.BufferInfo.pad)
}
#endif
inline void BufferInfo::set_pad(const char* value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.BufferInfo.pad)
}
inline void BufferInfo::set_pad(const char* value, size_t size) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.BufferInfo.pad)
}
inline ::std::string* BufferInfo::mutable_pad() {
  set_has_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.BufferInfo.pad)
  return pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BufferInfo::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.BufferInfo.pad)
  clear_has_pad();
  return pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BufferInfo::set_allocated_pad(::std::string* pad) {
  if (pad != NULL) {
    set_has_pad();
  } else {
    clear_has_pad();
  }
  pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.BufferInfo.pad)
}

// optional bytes data = 8;
inline bool BufferInfo::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BufferInfo::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BufferInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BufferInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& BufferInfo::data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferInfo.data)
  return data_.GetNoArena();
}
inline void BufferInfo::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.BufferInfo.data)
}
#if LANG_CXX11
inline void BufferInfo::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.BufferInfo.data)
}
#endif
inline void BufferInfo::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.BufferInfo.data)
}
inline void BufferInfo::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.BufferInfo.data)
}
inline ::std::string* BufferInfo::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:GstDebugger.BufferInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BufferInfo::release_data() {
  // @@protoc_insertion_point(field_release:GstDebugger.BufferInfo.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BufferInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.BufferInfo.data)
}

// -------------------------------------------------------------------

// TypeDescriptionRequest

// required string name = 1;
inline bool TypeDescriptionRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeDescriptionRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeDescriptionRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeDescriptionRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TypeDescriptionRequest::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TypeDescriptionRequest.name)
  return name_.GetNoArena();
}
inline void TypeDescriptionRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TypeDescriptionRequest.name)
}
#if LANG_CXX11
inline void TypeDescriptionRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TypeDescriptionRequest.name)
}
#endif
inline void TypeDescriptionRequest::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TypeDescriptionRequest.name)
}
inline void TypeDescriptionRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TypeDescriptionRequest.name)
}
inline ::std::string* TypeDescriptionRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TypeDescriptionRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TypeDescriptionRequest::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.TypeDescriptionRequest.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TypeDescriptionRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TypeDescriptionRequest.name)
}

// required .GstDebugger.TypeDescriptionRequest.Type type = 2;
inline bool TypeDescriptionRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeDescriptionRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeDescriptionRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TypeDescriptionRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::GstDebugger::TypeDescriptionRequest_Type TypeDescriptionRequest::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TypeDescriptionRequest.type)
  return static_cast< ::GstDebugger::TypeDescriptionRequest_Type >(type_);
}
inline void TypeDescriptionRequest::set_type(::GstDebugger::TypeDescriptionRequest_Type value) {
  assert(::GstDebugger::TypeDescriptionRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TypeDescriptionRequest.type)
}

// -------------------------------------------------------------------

// QueryHookRequest

// required int32 type = 1;
inline bool QueryHookRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryHookRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryHookRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryHookRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 QueryHookRequest::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.QueryHookRequest.type)
  return type_;
}
inline void QueryHookRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.QueryHookRequest.type)
}

// -------------------------------------------------------------------

// BufferHookRequest

// required bool send_data = 1;
inline bool BufferHookRequest::has_send_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BufferHookRequest::set_has_send_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BufferHookRequest::clear_has_send_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BufferHookRequest::clear_send_data() {
  send_data_ = false;
  clear_has_send_data();
}
inline bool BufferHookRequest::send_data() const {
  // @@protoc_insertion_point(field_get:GstDebugger.BufferHookRequest.send_data)
  return send_data_;
}
inline void BufferHookRequest::set_send_data(bool value) {
  set_has_send_data();
  send_data_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.BufferHookRequest.send_data)
}

// -------------------------------------------------------------------

// EventHookRequest

// required int32 type = 1;
inline bool EventHookRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventHookRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventHookRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventHookRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 EventHookRequest::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EventHookRequest.type)
  return type_;
}
inline void EventHookRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EventHookRequest.type)
}

// -------------------------------------------------------------------

// PadHookRequest

// optional string pad = 1;
inline bool PadHookRequest::has_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PadHookRequest::set_has_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PadHookRequest::clear_has_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PadHookRequest::clear_pad() {
  pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pad();
}
inline const ::std::string& PadHookRequest::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadHookRequest.pad)
  return pad_.GetNoArena();
}
inline void PadHookRequest::set_pad(const ::std::string& value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadHookRequest.pad)
}
#if LANG_CXX11
inline void PadHookRequest::set_pad(::std::string&& value) {
  set_has_pad();
  pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadHookRequest.pad)
}
#endif
inline void PadHookRequest::set_pad(const char* value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadHookRequest.pad)
}
inline void PadHookRequest::set_pad(const char* value, size_t size) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadHookRequest.pad)
}
inline ::std::string* PadHookRequest::mutable_pad() {
  set_has_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadHookRequest.pad)
  return pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadHookRequest::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadHookRequest.pad)
  clear_has_pad();
  return pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadHookRequest::set_allocated_pad(::std::string* pad) {
  if (pad != NULL) {
    set_has_pad();
  } else {
    clear_has_pad();
  }
  pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadHookRequest.pad)
}

// optional .GstDebugger.QueryHookRequest query = 2;
inline bool PadHookRequest::has_query() const {
  return pad_hook_type_case() == kQuery;
}
inline void PadHookRequest::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void PadHookRequest::clear_query() {
  if (has_query()) {
    delete pad_hook_type_.query_;
    clear_has_pad_hook_type();
  }
}
inline  const ::GstDebugger::QueryHookRequest& PadHookRequest::query() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadHookRequest.query)
  return has_query()
      ? *pad_hook_type_.query_
      : ::GstDebugger::QueryHookRequest::default_instance();
}
inline ::GstDebugger::QueryHookRequest* PadHookRequest::mutable_query() {
  if (!has_query()) {
    clear_pad_hook_type();
    set_has_query();
    pad_hook_type_.query_ = new ::GstDebugger::QueryHookRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadHookRequest.query)
  return pad_hook_type_.query_;
}
inline ::GstDebugger::QueryHookRequest* PadHookRequest::release_query() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadHookRequest.query)
  if (has_query()) {
    clear_has_pad_hook_type();
    ::GstDebugger::QueryHookRequest* temp = pad_hook_type_.query_;
    pad_hook_type_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PadHookRequest::set_allocated_query(::GstDebugger::QueryHookRequest* query) {
  clear_pad_hook_type();
  if (query) {
    set_has_query();
    pad_hook_type_.query_ = query;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadHookRequest.query)
}

// optional .GstDebugger.BufferHookRequest buffer = 3;
inline bool PadHookRequest::has_buffer() const {
  return pad_hook_type_case() == kBuffer;
}
inline void PadHookRequest::set_has_buffer() {
  _oneof_case_[0] = kBuffer;
}
inline void PadHookRequest::clear_buffer() {
  if (has_buffer()) {
    delete pad_hook_type_.buffer_;
    clear_has_pad_hook_type();
  }
}
inline  const ::GstDebugger::BufferHookRequest& PadHookRequest::buffer() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadHookRequest.buffer)
  return has_buffer()
      ? *pad_hook_type_.buffer_
      : ::GstDebugger::BufferHookRequest::default_instance();
}
inline ::GstDebugger::BufferHookRequest* PadHookRequest::mutable_buffer() {
  if (!has_buffer()) {
    clear_pad_hook_type();
    set_has_buffer();
    pad_hook_type_.buffer_ = new ::GstDebugger::BufferHookRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadHookRequest.buffer)
  return pad_hook_type_.buffer_;
}
inline ::GstDebugger::BufferHookRequest* PadHookRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadHookRequest.buffer)
  if (has_buffer()) {
    clear_has_pad_hook_type();
    ::GstDebugger::BufferHookRequest* temp = pad_hook_type_.buffer_;
    pad_hook_type_.buffer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PadHookRequest::set_allocated_buffer(::GstDebugger::BufferHookRequest* buffer) {
  clear_pad_hook_type();
  if (buffer) {
    set_has_buffer();
    pad_hook_type_.buffer_ = buffer;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadHookRequest.buffer)
}

// optional .GstDebugger.EventHookRequest event = 4;
inline bool PadHookRequest::has_event() const {
  return pad_hook_type_case() == kEvent;
}
inline void PadHookRequest::set_has_event() {
  _oneof_case_[0] = kEvent;
}
inline void PadHookRequest::clear_event() {
  if (has_event()) {
    delete pad_hook_type_.event_;
    clear_has_pad_hook_type();
  }
}
inline  const ::GstDebugger::EventHookRequest& PadHookRequest::event() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadHookRequest.event)
  return has_event()
      ? *pad_hook_type_.event_
      : ::GstDebugger::EventHookRequest::default_instance();
}
inline ::GstDebugger::EventHookRequest* PadHookRequest::mutable_event() {
  if (!has_event()) {
    clear_pad_hook_type();
    set_has_event();
    pad_hook_type_.event_ = new ::GstDebugger::EventHookRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadHookRequest.event)
  return pad_hook_type_.event_;
}
inline ::GstDebugger::EventHookRequest* PadHookRequest::release_event() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadHookRequest.event)
  if (has_event()) {
    clear_has_pad_hook_type();
    ::GstDebugger::EventHookRequest* temp = pad_hook_type_.event_;
    pad_hook_type_.event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PadHookRequest::set_allocated_event(::GstDebugger::EventHookRequest* event) {
  clear_pad_hook_type();
  if (event) {
    set_has_event();
    pad_hook_type_.event_ = event;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadHookRequest.event)
}

inline bool PadHookRequest::has_pad_hook_type() const {
  return pad_hook_type_case() != PAD_HOOK_TYPE_NOT_SET;
}
inline void PadHookRequest::clear_has_pad_hook_type() {
  _oneof_case_[0] = PAD_HOOK_TYPE_NOT_SET;
}
inline PadHookRequest::PadHookTypeCase PadHookRequest::pad_hook_type_case() const {
  return PadHookRequest::PadHookTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LogRequest

// required int32 level = 1;
inline bool LogRequest::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogRequest::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogRequest::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogRequest::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 LogRequest::level() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogRequest.level)
  return level_;
}
inline void LogRequest::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.LogRequest.level)
}

// optional string category = 2;
inline bool LogRequest::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogRequest::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogRequest::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogRequest::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& LogRequest::category() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogRequest.category)
  return category_.GetNoArena();
}
inline void LogRequest::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogRequest.category)
}
#if LANG_CXX11
inline void LogRequest::set_category(::std::string&& value) {
  set_has_category();
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogRequest.category)
}
#endif
inline void LogRequest::set_category(const char* value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogRequest.category)
}
inline void LogRequest::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogRequest.category)
}
inline ::std::string* LogRequest::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogRequest.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogRequest::release_category() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogRequest.category)
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogRequest::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogRequest.category)
}

// -------------------------------------------------------------------

// MessageRequest

// required int32 type = 1;
inline bool MessageRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MessageRequest::type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.MessageRequest.type)
  return type_;
}
inline void MessageRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.MessageRequest.type)
}

// -------------------------------------------------------------------

// HookRequest

// required .GstDebugger.Action action = 1;
inline bool HookRequest::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HookRequest::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HookRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HookRequest::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::GstDebugger::Action HookRequest::action() const {
  // @@protoc_insertion_point(field_get:GstDebugger.HookRequest.action)
  return static_cast< ::GstDebugger::Action >(action_);
}
inline void HookRequest::set_action(::GstDebugger::Action value) {
  assert(::GstDebugger::Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.HookRequest.action)
}

// optional .GstDebugger.MessageRequest message = 2;
inline bool HookRequest::has_message() const {
  return hook_type_case() == kMessage;
}
inline void HookRequest::set_has_message() {
  _oneof_case_[0] = kMessage;
}
inline void HookRequest::clear_message() {
  if (has_message()) {
    delete hook_type_.message_;
    clear_has_hook_type();
  }
}
inline  const ::GstDebugger::MessageRequest& HookRequest::message() const {
  // @@protoc_insertion_point(field_get:GstDebugger.HookRequest.message)
  return has_message()
      ? *hook_type_.message_
      : ::GstDebugger::MessageRequest::default_instance();
}
inline ::GstDebugger::MessageRequest* HookRequest::mutable_message() {
  if (!has_message()) {
    clear_hook_type();
    set_has_message();
    hook_type_.message_ = new ::GstDebugger::MessageRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.HookRequest.message)
  return hook_type_.message_;
}
inline ::GstDebugger::MessageRequest* HookRequest::release_message() {
  // @@protoc_insertion_point(field_release:GstDebugger.HookRequest.message)
  if (has_message()) {
    clear_has_hook_type();
    ::GstDebugger::MessageRequest* temp = hook_type_.message_;
    hook_type_.message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HookRequest::set_allocated_message(::GstDebugger::MessageRequest* message) {
  clear_hook_type();
  if (message) {
    set_has_message();
    hook_type_.message_ = message;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.HookRequest.message)
}

// optional .GstDebugger.LogRequest log = 3;
inline bool HookRequest::has_log() const {
  return hook_type_case() == kLog;
}
inline void HookRequest::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void HookRequest::clear_log() {
  if (has_log()) {
    delete hook_type_.log_;
    clear_has_hook_type();
  }
}
inline  const ::GstDebugger::LogRequest& HookRequest::log() const {
  // @@protoc_insertion_point(field_get:GstDebugger.HookRequest.log)
  return has_log()
      ? *hook_type_.log_
      : ::GstDebugger::LogRequest::default_instance();
}
inline ::GstDebugger::LogRequest* HookRequest::mutable_log() {
  if (!has_log()) {
    clear_hook_type();
    set_has_log();
    hook_type_.log_ = new ::GstDebugger::LogRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.HookRequest.log)
  return hook_type_.log_;
}
inline ::GstDebugger::LogRequest* HookRequest::release_log() {
  // @@protoc_insertion_point(field_release:GstDebugger.HookRequest.log)
  if (has_log()) {
    clear_has_hook_type();
    ::GstDebugger::LogRequest* temp = hook_type_.log_;
    hook_type_.log_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HookRequest::set_allocated_log(::GstDebugger::LogRequest* log) {
  clear_hook_type();
  if (log) {
    set_has_log();
    hook_type_.log_ = log;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.HookRequest.log)
}

// optional .GstDebugger.PadHookRequest pad_hook = 4;
inline bool HookRequest::has_pad_hook() const {
  return hook_type_case() == kPadHook;
}
inline void HookRequest::set_has_pad_hook() {
  _oneof_case_[0] = kPadHook;
}
inline void HookRequest::clear_pad_hook() {
  if (has_pad_hook()) {
    delete hook_type_.pad_hook_;
    clear_has_hook_type();
  }
}
inline  const ::GstDebugger::PadHookRequest& HookRequest::pad_hook() const {
  // @@protoc_insertion_point(field_get:GstDebugger.HookRequest.pad_hook)
  return has_pad_hook()
      ? *hook_type_.pad_hook_
      : ::GstDebugger::PadHookRequest::default_instance();
}
inline ::GstDebugger::PadHookRequest* HookRequest::mutable_pad_hook() {
  if (!has_pad_hook()) {
    clear_hook_type();
    set_has_pad_hook();
    hook_type_.pad_hook_ = new ::GstDebugger::PadHookRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.HookRequest.pad_hook)
  return hook_type_.pad_hook_;
}
inline ::GstDebugger::PadHookRequest* HookRequest::release_pad_hook() {
  // @@protoc_insertion_point(field_release:GstDebugger.HookRequest.pad_hook)
  if (has_pad_hook()) {
    clear_has_hook_type();
    ::GstDebugger::PadHookRequest* temp = hook_type_.pad_hook_;
    hook_type_.pad_hook_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void HookRequest::set_allocated_pad_hook(::GstDebugger::PadHookRequest* pad_hook) {
  clear_hook_type();
  if (pad_hook) {
    set_has_pad_hook();
    hook_type_.pad_hook_ = pad_hook;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.HookRequest.pad_hook)
}

inline bool HookRequest::has_hook_type() const {
  return hook_type_case() != HOOK_TYPE_NOT_SET;
}
inline void HookRequest::clear_has_hook_type() {
  _oneof_case_[0] = HOOK_TYPE_NOT_SET;
}
inline HookRequest::HookTypeCase HookRequest::hook_type_case() const {
  return HookRequest::HookTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Command

// optional .GstDebugger.TypeDescriptionRequest type_description = 1;
inline bool Command::has_type_description() const {
  return command_type_case() == kTypeDescription;
}
inline void Command::set_has_type_description() {
  _oneof_case_[0] = kTypeDescription;
}
inline void Command::clear_type_description() {
  if (has_type_description()) {
    delete command_type_.type_description_;
    clear_has_command_type();
  }
}
inline  const ::GstDebugger::TypeDescriptionRequest& Command::type_description() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.type_description)
  return has_type_description()
      ? *command_type_.type_description_
      : ::GstDebugger::TypeDescriptionRequest::default_instance();
}
inline ::GstDebugger::TypeDescriptionRequest* Command::mutable_type_description() {
  if (!has_type_description()) {
    clear_command_type();
    set_has_type_description();
    command_type_.type_description_ = new ::GstDebugger::TypeDescriptionRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.type_description)
  return command_type_.type_description_;
}
inline ::GstDebugger::TypeDescriptionRequest* Command::release_type_description() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.type_description)
  if (has_type_description()) {
    clear_has_command_type();
    ::GstDebugger::TypeDescriptionRequest* temp = command_type_.type_description_;
    command_type_.type_description_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_type_description(::GstDebugger::TypeDescriptionRequest* type_description) {
  clear_command_type();
  if (type_description) {
    set_has_type_description();
    command_type_.type_description_ = type_description;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.type_description)
}

// optional bool debug_categories_list = 2;
inline bool Command::has_debug_categories_list() const {
  return command_type_case() == kDebugCategoriesList;
}
inline void Command::set_has_debug_categories_list() {
  _oneof_case_[0] = kDebugCategoriesList;
}
inline void Command::clear_debug_categories_list() {
  if (has_debug_categories_list()) {
    command_type_.debug_categories_list_ = false;
    clear_has_command_type();
  }
}
inline bool Command::debug_categories_list() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.debug_categories_list)
  if (has_debug_categories_list()) {
    return command_type_.debug_categories_list_;
  }
  return false;
}
inline void Command::set_debug_categories_list(bool value) {
  if (!has_debug_categories_list()) {
    clear_command_type();
    set_has_debug_categories_list();
  }
  command_type_.debug_categories_list_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.Command.debug_categories_list)
}

// optional .GstDebugger.HookRequest hook_request = 3;
inline bool Command::has_hook_request() const {
  return command_type_case() == kHookRequest;
}
inline void Command::set_has_hook_request() {
  _oneof_case_[0] = kHookRequest;
}
inline void Command::clear_hook_request() {
  if (has_hook_request()) {
    delete command_type_.hook_request_;
    clear_has_command_type();
  }
}
inline  const ::GstDebugger::HookRequest& Command::hook_request() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.hook_request)
  return has_hook_request()
      ? *command_type_.hook_request_
      : ::GstDebugger::HookRequest::default_instance();
}
inline ::GstDebugger::HookRequest* Command::mutable_hook_request() {
  if (!has_hook_request()) {
    clear_command_type();
    set_has_hook_request();
    command_type_.hook_request_ = new ::GstDebugger::HookRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.hook_request)
  return command_type_.hook_request_;
}
inline ::GstDebugger::HookRequest* Command::release_hook_request() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.hook_request)
  if (has_hook_request()) {
    clear_has_command_type();
    ::GstDebugger::HookRequest* temp = command_type_.hook_request_;
    command_type_.hook_request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_hook_request(::GstDebugger::HookRequest* hook_request) {
  clear_command_type();
  if (hook_request) {
    set_has_hook_request();
    command_type_.hook_request_ = hook_request;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.hook_request)
}

// optional string log_threshold = 4;
inline bool Command::has_log_threshold() const {
  return command_type_case() == kLogThreshold;
}
inline void Command::set_has_log_threshold() {
  _oneof_case_[0] = kLogThreshold;
}
inline void Command::clear_log_threshold() {
  if (has_log_threshold()) {
    command_type_.log_threshold_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_command_type();
  }
}
inline const ::std::string& Command::log_threshold() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.log_threshold)
  if (has_log_threshold()) {
    return command_type_.log_threshold_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Command::set_log_threshold(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GstDebugger.Command.log_threshold)
  if (!has_log_threshold()) {
    clear_command_type();
    set_has_log_threshold();
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.log_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.Command.log_threshold)
}
#if LANG_CXX11
inline void Command::set_log_threshold(::std::string&& value) {
  // @@protoc_insertion_point(field_set:GstDebugger.Command.log_threshold)
  if (!has_log_threshold()) {
    clear_command_type();
    set_has_log_threshold();
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.log_threshold_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.Command.log_threshold)
}
#endif
inline void Command::set_log_threshold(const char* value) {
  if (!has_log_threshold()) {
    clear_command_type();
    set_has_log_threshold();
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.log_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.Command.log_threshold)
}
inline void Command::set_log_threshold(const char* value, size_t size) {
  if (!has_log_threshold()) {
    clear_command_type();
    set_has_log_threshold();
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.log_threshold_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.Command.log_threshold)
}
inline ::std::string* Command::mutable_log_threshold() {
  if (!has_log_threshold()) {
    clear_command_type();
    set_has_log_threshold();
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.log_threshold)
  return command_type_.log_threshold_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_log_threshold() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.log_threshold)
  if (has_log_threshold()) {
    clear_has_command_type();
    return command_type_.log_threshold_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_log_threshold(::std::string* log_threshold) {
  if (!has_log_threshold()) {
    command_type_.log_threshold_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_command_type();
  if (log_threshold != NULL) {
    set_has_log_threshold();
    command_type_.log_threshold_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        log_threshold);
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.log_threshold)
}

// optional bool entire_topology = 5;
inline bool Command::has_entire_topology() const {
  return command_type_case() == kEntireTopology;
}
inline void Command::set_has_entire_topology() {
  _oneof_case_[0] = kEntireTopology;
}
inline void Command::clear_entire_topology() {
  if (has_entire_topology()) {
    command_type_.entire_topology_ = false;
    clear_has_command_type();
  }
}
inline bool Command::entire_topology() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.entire_topology)
  if (has_entire_topology()) {
    return command_type_.entire_topology_;
  }
  return false;
}
inline void Command::set_entire_topology(bool value) {
  if (!has_entire_topology()) {
    clear_command_type();
    set_has_entire_topology();
  }
  command_type_.entire_topology_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.Command.entire_topology)
}

// optional .GstDebugger.PropertyRequest property = 6;
inline bool Command::has_property() const {
  return command_type_case() == kProperty;
}
inline void Command::set_has_property() {
  _oneof_case_[0] = kProperty;
}
inline void Command::clear_property() {
  if (has_property()) {
    delete command_type_.property_;
    clear_has_command_type();
  }
}
inline  const ::GstDebugger::PropertyRequest& Command::property() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.property)
  return has_property()
      ? *command_type_.property_
      : ::GstDebugger::PropertyRequest::default_instance();
}
inline ::GstDebugger::PropertyRequest* Command::mutable_property() {
  if (!has_property()) {
    clear_command_type();
    set_has_property();
    command_type_.property_ = new ::GstDebugger::PropertyRequest;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.property)
  return command_type_.property_;
}
inline ::GstDebugger::PropertyRequest* Command::release_property() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.property)
  if (has_property()) {
    clear_has_command_type();
    ::GstDebugger::PropertyRequest* temp = command_type_.property_;
    command_type_.property_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_property(::GstDebugger::PropertyRequest* property) {
  clear_command_type();
  if (property) {
    set_has_property();
    command_type_.property_ = property;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.property)
}

// optional .GstDebugger.PropertyValue property_set = 7;
inline bool Command::has_property_set() const {
  return command_type_case() == kPropertySet;
}
inline void Command::set_has_property_set() {
  _oneof_case_[0] = kPropertySet;
}
inline void Command::clear_property_set() {
  if (has_property_set()) {
    delete command_type_.property_set_;
    clear_has_command_type();
  }
}
inline  const ::GstDebugger::PropertyValue& Command::property_set() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.property_set)
  return has_property_set()
      ? *command_type_.property_set_
      : ::GstDebugger::PropertyValue::default_instance();
}
inline ::GstDebugger::PropertyValue* Command::mutable_property_set() {
  if (!has_property_set()) {
    clear_command_type();
    set_has_property_set();
    command_type_.property_set_ = new ::GstDebugger::PropertyValue;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.property_set)
  return command_type_.property_set_;
}
inline ::GstDebugger::PropertyValue* Command::release_property_set() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.property_set)
  if (has_property_set()) {
    clear_has_command_type();
    ::GstDebugger::PropertyValue* temp = command_type_.property_set_;
    command_type_.property_set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_property_set(::GstDebugger::PropertyValue* property_set) {
  clear_command_type();
  if (property_set) {
    set_has_property_set();
    command_type_.property_set_ = property_set;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.property_set)
}

// optional string pad_dynamic_info = 8;
inline bool Command::has_pad_dynamic_info() const {
  return command_type_case() == kPadDynamicInfo;
}
inline void Command::set_has_pad_dynamic_info() {
  _oneof_case_[0] = kPadDynamicInfo;
}
inline void Command::clear_pad_dynamic_info() {
  if (has_pad_dynamic_info()) {
    command_type_.pad_dynamic_info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_command_type();
  }
}
inline const ::std::string& Command::pad_dynamic_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.Command.pad_dynamic_info)
  if (has_pad_dynamic_info()) {
    return command_type_.pad_dynamic_info_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Command::set_pad_dynamic_info(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GstDebugger.Command.pad_dynamic_info)
  if (!has_pad_dynamic_info()) {
    clear_command_type();
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.pad_dynamic_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.Command.pad_dynamic_info)
}
#if LANG_CXX11
inline void Command::set_pad_dynamic_info(::std::string&& value) {
  // @@protoc_insertion_point(field_set:GstDebugger.Command.pad_dynamic_info)
  if (!has_pad_dynamic_info()) {
    clear_command_type();
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.pad_dynamic_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.Command.pad_dynamic_info)
}
#endif
inline void Command::set_pad_dynamic_info(const char* value) {
  if (!has_pad_dynamic_info()) {
    clear_command_type();
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.pad_dynamic_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.Command.pad_dynamic_info)
}
inline void Command::set_pad_dynamic_info(const char* value, size_t size) {
  if (!has_pad_dynamic_info()) {
    clear_command_type();
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  command_type_.pad_dynamic_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.Command.pad_dynamic_info)
}
inline ::std::string* Command::mutable_pad_dynamic_info() {
  if (!has_pad_dynamic_info()) {
    clear_command_type();
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.Command.pad_dynamic_info)
  return command_type_.pad_dynamic_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_pad_dynamic_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.Command.pad_dynamic_info)
  if (has_pad_dynamic_info()) {
    clear_has_command_type();
    return command_type_.pad_dynamic_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Command::set_allocated_pad_dynamic_info(::std::string* pad_dynamic_info) {
  if (!has_pad_dynamic_info()) {
    command_type_.pad_dynamic_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_command_type();
  if (pad_dynamic_info != NULL) {
    set_has_pad_dynamic_info();
    command_type_.pad_dynamic_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        pad_dynamic_info);
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.Command.pad_dynamic_info)
}

inline bool Command::has_command_type() const {
  return command_type_case() != COMMAND_TYPE_NOT_SET;
}
inline void Command::clear_has_command_type() {
  _oneof_case_[0] = COMMAND_TYPE_NOT_SET;
}
inline Command::CommandTypeCase Command::command_type_case() const {
  return Command::CommandTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DebugCategories

// repeated string category = 1;
inline int DebugCategories::category_size() const {
  return category_.size();
}
inline void DebugCategories::clear_category() {
  category_.Clear();
}
inline const ::std::string& DebugCategories::category(int index) const {
  // @@protoc_insertion_point(field_get:GstDebugger.DebugCategories.category)
  return category_.Get(index);
}
inline ::std::string* DebugCategories::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:GstDebugger.DebugCategories.category)
  return category_.Mutable(index);
}
inline void DebugCategories::set_category(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GstDebugger.DebugCategories.category)
  category_.Mutable(index)->assign(value);
}
inline void DebugCategories::set_category(int index, const char* value) {
  category_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GstDebugger.DebugCategories.category)
}
inline void DebugCategories::set_category(int index, const char* value, size_t size) {
  category_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.DebugCategories.category)
}
inline ::std::string* DebugCategories::add_category() {
  // @@protoc_insertion_point(field_add_mutable:GstDebugger.DebugCategories.category)
  return category_.Add();
}
inline void DebugCategories::add_category(const ::std::string& value) {
  category_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GstDebugger.DebugCategories.category)
}
inline void DebugCategories::add_category(const char* value) {
  category_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GstDebugger.DebugCategories.category)
}
inline void DebugCategories::add_category(const char* value, size_t size) {
  category_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GstDebugger.DebugCategories.category)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DebugCategories::category() const {
  // @@protoc_insertion_point(field_list:GstDebugger.DebugCategories.category)
  return category_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DebugCategories::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:GstDebugger.DebugCategories.category)
  return &category_;
}

// -------------------------------------------------------------------

// LogInfo

// required int32 level = 1;
inline bool LogInfo::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LogInfo::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LogInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LogInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 LogInfo::level() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.level)
  return level_;
}
inline void LogInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.level)
}

// required string category = 2;
inline bool LogInfo::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogInfo::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogInfo::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogInfo::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& LogInfo::category() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.category)
  return category_.GetNoArena();
}
inline void LogInfo::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.category)
}
#if LANG_CXX11
inline void LogInfo::set_category(::std::string&& value) {
  set_has_category();
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogInfo.category)
}
#endif
inline void LogInfo::set_category(const char* value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogInfo.category)
}
inline void LogInfo::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogInfo.category)
}
inline ::std::string* LogInfo::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogInfo.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInfo::release_category() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogInfo.category)
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInfo::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogInfo.category)
}

// required string file = 3;
inline bool LogInfo::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogInfo::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogInfo::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogInfo::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file();
}
inline const ::std::string& LogInfo::file() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.file)
  return file_.GetNoArena();
}
inline void LogInfo::set_file(const ::std::string& value) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.file)
}
#if LANG_CXX11
inline void LogInfo::set_file(::std::string&& value) {
  set_has_file();
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogInfo.file)
}
#endif
inline void LogInfo::set_file(const char* value) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogInfo.file)
}
inline void LogInfo::set_file(const char* value, size_t size) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogInfo.file)
}
inline ::std::string* LogInfo::mutable_file() {
  set_has_file();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogInfo.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInfo::release_file() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogInfo.file)
  clear_has_file();
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInfo::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    set_has_file();
  } else {
    clear_has_file();
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogInfo.file)
}

// required string function = 4;
inline bool LogInfo::has_function() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogInfo::set_has_function() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogInfo::clear_has_function() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogInfo::clear_function() {
  function_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_function();
}
inline const ::std::string& LogInfo::function() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.function)
  return function_.GetNoArena();
}
inline void LogInfo::set_function(const ::std::string& value) {
  set_has_function();
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.function)
}
#if LANG_CXX11
inline void LogInfo::set_function(::std::string&& value) {
  set_has_function();
  function_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogInfo.function)
}
#endif
inline void LogInfo::set_function(const char* value) {
  set_has_function();
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogInfo.function)
}
inline void LogInfo::set_function(const char* value, size_t size) {
  set_has_function();
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogInfo.function)
}
inline ::std::string* LogInfo::mutable_function() {
  set_has_function();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogInfo.function)
  return function_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInfo::release_function() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogInfo.function)
  clear_has_function();
  return function_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInfo::set_allocated_function(::std::string* function) {
  if (function != NULL) {
    set_has_function();
  } else {
    clear_has_function();
  }
  function_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogInfo.function)
}

// required int32 line = 5;
inline bool LogInfo::has_line() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LogInfo::set_has_line() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LogInfo::clear_has_line() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LogInfo::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 LogInfo::line() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.line)
  return line_;
}
inline void LogInfo::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.line)
}

// required string object = 6;
inline bool LogInfo::has_object() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogInfo::set_has_object() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogInfo::clear_has_object() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogInfo::clear_object() {
  object_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_object();
}
inline const ::std::string& LogInfo::object() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.object)
  return object_.GetNoArena();
}
inline void LogInfo::set_object(const ::std::string& value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.object)
}
#if LANG_CXX11
inline void LogInfo::set_object(::std::string&& value) {
  set_has_object();
  object_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogInfo.object)
}
#endif
inline void LogInfo::set_object(const char* value) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogInfo.object)
}
inline void LogInfo::set_object(const char* value, size_t size) {
  set_has_object();
  object_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogInfo.object)
}
inline ::std::string* LogInfo::mutable_object() {
  set_has_object();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogInfo.object)
  return object_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInfo::release_object() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogInfo.object)
  clear_has_object();
  return object_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInfo::set_allocated_object(::std::string* object) {
  if (object != NULL) {
    set_has_object();
  } else {
    clear_has_object();
  }
  object_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), object);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogInfo.object)
}

// required string message = 7;
inline bool LogInfo::has_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogInfo::set_has_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogInfo::clear_has_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogInfo::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& LogInfo::message() const {
  // @@protoc_insertion_point(field_get:GstDebugger.LogInfo.message)
  return message_.GetNoArena();
}
inline void LogInfo::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.LogInfo.message)
}
#if LANG_CXX11
inline void LogInfo::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.LogInfo.message)
}
#endif
inline void LogInfo::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.LogInfo.message)
}
inline void LogInfo::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.LogInfo.message)
}
inline ::std::string* LogInfo::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:GstDebugger.LogInfo.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInfo::release_message() {
  // @@protoc_insertion_point(field_release:GstDebugger.LogInfo.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInfo::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.LogInfo.message)
}

// -------------------------------------------------------------------

// EnumFlagsValue

// required string name = 1;
inline bool EnumFlagsValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumFlagsValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumFlagsValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumFlagsValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumFlagsValue::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsValue.name)
  return name_.GetNoArena();
}
inline void EnumFlagsValue::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.EnumFlagsValue.name)
}
#if LANG_CXX11
inline void EnumFlagsValue::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.EnumFlagsValue.name)
}
#endif
inline void EnumFlagsValue::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.EnumFlagsValue.name)
}
inline void EnumFlagsValue::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.EnumFlagsValue.name)
}
inline ::std::string* EnumFlagsValue::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.EnumFlagsValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumFlagsValue::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.EnumFlagsValue.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumFlagsValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.EnumFlagsValue.name)
}

// required int32 value = 2;
inline bool EnumFlagsValue::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnumFlagsValue::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnumFlagsValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnumFlagsValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EnumFlagsValue::value() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsValue.value)
  return value_;
}
inline void EnumFlagsValue::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EnumFlagsValue.value)
}

// required string nick = 3;
inline bool EnumFlagsValue::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumFlagsValue::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumFlagsValue::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumFlagsValue::clear_nick() {
  nick_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nick();
}
inline const ::std::string& EnumFlagsValue::nick() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsValue.nick)
  return nick_.GetNoArena();
}
inline void EnumFlagsValue::set_nick(const ::std::string& value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.EnumFlagsValue.nick)
}
#if LANG_CXX11
inline void EnumFlagsValue::set_nick(::std::string&& value) {
  set_has_nick();
  nick_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.EnumFlagsValue.nick)
}
#endif
inline void EnumFlagsValue::set_nick(const char* value) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.EnumFlagsValue.nick)
}
inline void EnumFlagsValue::set_nick(const char* value, size_t size) {
  set_has_nick();
  nick_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.EnumFlagsValue.nick)
}
inline ::std::string* EnumFlagsValue::mutable_nick() {
  set_has_nick();
  // @@protoc_insertion_point(field_mutable:GstDebugger.EnumFlagsValue.nick)
  return nick_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumFlagsValue::release_nick() {
  // @@protoc_insertion_point(field_release:GstDebugger.EnumFlagsValue.nick)
  clear_has_nick();
  return nick_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumFlagsValue::set_allocated_nick(::std::string* nick) {
  if (nick != NULL) {
    set_has_nick();
  } else {
    clear_has_nick();
  }
  nick_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.EnumFlagsValue.nick)
}

// -------------------------------------------------------------------

// EnumFlagsType

// required string type_name = 1;
inline bool EnumFlagsType::has_type_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumFlagsType::set_has_type_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumFlagsType::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumFlagsType::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
inline const ::std::string& EnumFlagsType::type_name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsType.type_name)
  return type_name_.GetNoArena();
}
inline void EnumFlagsType::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.EnumFlagsType.type_name)
}
#if LANG_CXX11
inline void EnumFlagsType::set_type_name(::std::string&& value) {
  set_has_type_name();
  type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.EnumFlagsType.type_name)
}
#endif
inline void EnumFlagsType::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.EnumFlagsType.type_name)
}
inline void EnumFlagsType::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.EnumFlagsType.type_name)
}
inline ::std::string* EnumFlagsType::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.EnumFlagsType.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumFlagsType::release_type_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.EnumFlagsType.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumFlagsType::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.EnumFlagsType.type_name)
}

// required .GstDebugger.EnumFlagsType.EnumFlagsKind kind = 2;
inline bool EnumFlagsType::has_kind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumFlagsType::set_has_kind() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumFlagsType::clear_has_kind() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumFlagsType::clear_kind() {
  kind_ = 0;
  clear_has_kind();
}
inline ::GstDebugger::EnumFlagsType_EnumFlagsKind EnumFlagsType::kind() const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsType.kind)
  return static_cast< ::GstDebugger::EnumFlagsType_EnumFlagsKind >(kind_);
}
inline void EnumFlagsType::set_kind(::GstDebugger::EnumFlagsType_EnumFlagsKind value) {
  assert(::GstDebugger::EnumFlagsType_EnumFlagsKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.EnumFlagsType.kind)
}

// repeated .GstDebugger.EnumFlagsValue values = 3;
inline int EnumFlagsType::values_size() const {
  return values_.size();
}
inline void EnumFlagsType::clear_values() {
  values_.Clear();
}
inline const ::GstDebugger::EnumFlagsValue& EnumFlagsType::values(int index) const {
  // @@protoc_insertion_point(field_get:GstDebugger.EnumFlagsType.values)
  return values_.Get(index);
}
inline ::GstDebugger::EnumFlagsValue* EnumFlagsType::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:GstDebugger.EnumFlagsType.values)
  return values_.Mutable(index);
}
inline ::GstDebugger::EnumFlagsValue* EnumFlagsType::add_values() {
  // @@protoc_insertion_point(field_add:GstDebugger.EnumFlagsType.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GstDebugger::EnumFlagsValue >*
EnumFlagsType::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:GstDebugger.EnumFlagsType.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GstDebugger::EnumFlagsValue >&
EnumFlagsType::values() const {
  // @@protoc_insertion_point(field_list:GstDebugger.EnumFlagsType.values)
  return values_;
}

// -------------------------------------------------------------------

// FactoryMeta

// required string key = 1;
inline bool FactoryMeta::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FactoryMeta::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FactoryMeta::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FactoryMeta::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& FactoryMeta::key() const {
  // @@protoc_insertion_point(field_get:GstDebugger.FactoryMeta.key)
  return key_.GetNoArena();
}
inline void FactoryMeta::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.FactoryMeta.key)
}
#if LANG_CXX11
inline void FactoryMeta::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.FactoryMeta.key)
}
#endif
inline void FactoryMeta::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.FactoryMeta.key)
}
inline void FactoryMeta::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.FactoryMeta.key)
}
inline ::std::string* FactoryMeta::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:GstDebugger.FactoryMeta.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FactoryMeta::release_key() {
  // @@protoc_insertion_point(field_release:GstDebugger.FactoryMeta.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FactoryMeta::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.FactoryMeta.key)
}

// required string value = 2;
inline bool FactoryMeta::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FactoryMeta::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FactoryMeta::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FactoryMeta::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& FactoryMeta::value() const {
  // @@protoc_insertion_point(field_get:GstDebugger.FactoryMeta.value)
  return value_.GetNoArena();
}
inline void FactoryMeta::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.FactoryMeta.value)
}
#if LANG_CXX11
inline void FactoryMeta::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.FactoryMeta.value)
}
#endif
inline void FactoryMeta::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.FactoryMeta.value)
}
inline void FactoryMeta::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.FactoryMeta.value)
}
inline ::std::string* FactoryMeta::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:GstDebugger.FactoryMeta.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FactoryMeta::release_value() {
  // @@protoc_insertion_point(field_release:GstDebugger.FactoryMeta.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FactoryMeta::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.FactoryMeta.value)
}

// -------------------------------------------------------------------

// PadTemplate

// required string name_template = 1;
inline bool PadTemplate::has_name_template() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PadTemplate::set_has_name_template() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PadTemplate::clear_has_name_template() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PadTemplate::clear_name_template() {
  name_template_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name_template();
}
inline const ::std::string& PadTemplate::name_template() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadTemplate.name_template)
  return name_template_.GetNoArena();
}
inline void PadTemplate::set_name_template(const ::std::string& value) {
  set_has_name_template();
  name_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadTemplate.name_template)
}
#if LANG_CXX11
inline void PadTemplate::set_name_template(::std::string&& value) {
  set_has_name_template();
  name_template_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadTemplate.name_template)
}
#endif
inline void PadTemplate::set_name_template(const char* value) {
  set_has_name_template();
  name_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadTemplate.name_template)
}
inline void PadTemplate::set_name_template(const char* value, size_t size) {
  set_has_name_template();
  name_template_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadTemplate.name_template)
}
inline ::std::string* PadTemplate::mutable_name_template() {
  set_has_name_template();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadTemplate.name_template)
  return name_template_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadTemplate::release_name_template() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadTemplate.name_template)
  clear_has_name_template();
  return name_template_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadTemplate::set_allocated_name_template(::std::string* name_template) {
  if (name_template != NULL) {
    set_has_name_template();
  } else {
    clear_has_name_template();
  }
  name_template_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name_template);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadTemplate.name_template)
}

// required int32 direction = 2;
inline bool PadTemplate::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PadTemplate::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PadTemplate::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PadTemplate::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 PadTemplate::direction() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadTemplate.direction)
  return direction_;
}
inline void PadTemplate::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.PadTemplate.direction)
}

// required int32 presence = 3;
inline bool PadTemplate::has_presence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PadTemplate::set_has_presence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PadTemplate::clear_has_presence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PadTemplate::clear_presence() {
  presence_ = 0;
  clear_has_presence();
}
inline ::google::protobuf::int32 PadTemplate::presence() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadTemplate.presence)
  return presence_;
}
inline void PadTemplate::set_presence(::google::protobuf::int32 value) {
  set_has_presence();
  presence_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.PadTemplate.presence)
}

// required string caps = 4;
inline bool PadTemplate::has_caps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PadTemplate::set_has_caps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PadTemplate::clear_has_caps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PadTemplate::clear_caps() {
  caps_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_caps();
}
inline const ::std::string& PadTemplate::caps() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadTemplate.caps)
  return caps_.GetNoArena();
}
inline void PadTemplate::set_caps(const ::std::string& value) {
  set_has_caps();
  caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadTemplate.caps)
}
#if LANG_CXX11
inline void PadTemplate::set_caps(::std::string&& value) {
  set_has_caps();
  caps_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadTemplate.caps)
}
#endif
inline void PadTemplate::set_caps(const char* value) {
  set_has_caps();
  caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadTemplate.caps)
}
inline void PadTemplate::set_caps(const char* value, size_t size) {
  set_has_caps();
  caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadTemplate.caps)
}
inline ::std::string* PadTemplate::mutable_caps() {
  set_has_caps();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadTemplate.caps)
  return caps_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadTemplate::release_caps() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadTemplate.caps)
  clear_has_caps();
  return caps_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadTemplate::set_allocated_caps(::std::string* caps) {
  if (caps != NULL) {
    set_has_caps();
  } else {
    clear_has_caps();
  }
  caps_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), caps);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadTemplate.caps)
}

// -------------------------------------------------------------------

// FactoryType

// required string name = 1;
inline bool FactoryType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FactoryType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FactoryType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FactoryType::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FactoryType::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.FactoryType.name)
  return name_.GetNoArena();
}
inline void FactoryType::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.FactoryType.name)
}
#if LANG_CXX11
inline void FactoryType::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.FactoryType.name)
}
#endif
inline void FactoryType::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.FactoryType.name)
}
inline void FactoryType::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.FactoryType.name)
}
inline ::std::string* FactoryType::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.FactoryType.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FactoryType::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.FactoryType.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FactoryType::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.FactoryType.name)
}

// repeated .GstDebugger.FactoryMeta metadata = 2;
inline int FactoryType::metadata_size() const {
  return metadata_.size();
}
inline void FactoryType::clear_metadata() {
  metadata_.Clear();
}
inline const ::GstDebugger::FactoryMeta& FactoryType::metadata(int index) const {
  // @@protoc_insertion_point(field_get:GstDebugger.FactoryType.metadata)
  return metadata_.Get(index);
}
inline ::GstDebugger::FactoryMeta* FactoryType::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:GstDebugger.FactoryType.metadata)
  return metadata_.Mutable(index);
}
inline ::GstDebugger::FactoryMeta* FactoryType::add_metadata() {
  // @@protoc_insertion_point(field_add:GstDebugger.FactoryType.metadata)
  return metadata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GstDebugger::FactoryMeta >*
FactoryType::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:GstDebugger.FactoryType.metadata)
  return &metadata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GstDebugger::FactoryMeta >&
FactoryType::metadata() const {
  // @@protoc_insertion_point(field_list:GstDebugger.FactoryType.metadata)
  return metadata_;
}

// repeated .GstDebugger.PadTemplate templates = 3;
inline int FactoryType::templates_size() const {
  return templates_.size();
}
inline void FactoryType::clear_templates() {
  templates_.Clear();
}
inline const ::GstDebugger::PadTemplate& FactoryType::templates(int index) const {
  // @@protoc_insertion_point(field_get:GstDebugger.FactoryType.templates)
  return templates_.Get(index);
}
inline ::GstDebugger::PadTemplate* FactoryType::mutable_templates(int index) {
  // @@protoc_insertion_point(field_mutable:GstDebugger.FactoryType.templates)
  return templates_.Mutable(index);
}
inline ::GstDebugger::PadTemplate* FactoryType::add_templates() {
  // @@protoc_insertion_point(field_add:GstDebugger.FactoryType.templates)
  return templates_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GstDebugger::PadTemplate >*
FactoryType::mutable_templates() {
  // @@protoc_insertion_point(field_mutable_list:GstDebugger.FactoryType.templates)
  return &templates_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GstDebugger::PadTemplate >&
FactoryType::templates() const {
  // @@protoc_insertion_point(field_list:GstDebugger.FactoryType.templates)
  return templates_;
}

// -------------------------------------------------------------------

// ElementKlass

// required string name = 1;
inline bool ElementKlass::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ElementKlass::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ElementKlass::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ElementKlass::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ElementKlass::name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.ElementKlass.name)
  return name_.GetNoArena();
}
inline void ElementKlass::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.ElementKlass.name)
}
#if LANG_CXX11
inline void ElementKlass::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.ElementKlass.name)
}
#endif
inline void ElementKlass::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.ElementKlass.name)
}
inline void ElementKlass::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.ElementKlass.name)
}
inline ::std::string* ElementKlass::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.ElementKlass.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ElementKlass::release_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.ElementKlass.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ElementKlass::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.ElementKlass.name)
}

// repeated .GstDebugger.PropertyInfo property_info = 2;
inline int ElementKlass::property_info_size() const {
  return property_info_.size();
}
inline void ElementKlass::clear_property_info() {
  property_info_.Clear();
}
inline const ::GstDebugger::PropertyInfo& ElementKlass::property_info(int index) const {
  // @@protoc_insertion_point(field_get:GstDebugger.ElementKlass.property_info)
  return property_info_.Get(index);
}
inline ::GstDebugger::PropertyInfo* ElementKlass::mutable_property_info(int index) {
  // @@protoc_insertion_point(field_mutable:GstDebugger.ElementKlass.property_info)
  return property_info_.Mutable(index);
}
inline ::GstDebugger::PropertyInfo* ElementKlass::add_property_info() {
  // @@protoc_insertion_point(field_add:GstDebugger.ElementKlass.property_info)
  return property_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::GstDebugger::PropertyInfo >*
ElementKlass::mutable_property_info() {
  // @@protoc_insertion_point(field_mutable_list:GstDebugger.ElementKlass.property_info)
  return &property_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::GstDebugger::PropertyInfo >&
ElementKlass::property_info() const {
  // @@protoc_insertion_point(field_list:GstDebugger.ElementKlass.property_info)
  return property_info_;
}

// -------------------------------------------------------------------

// TopologyLink

// required string src_pad = 1;
inline bool TopologyLink::has_src_pad() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopologyLink::set_has_src_pad() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopologyLink::clear_has_src_pad() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopologyLink::clear_src_pad() {
  src_pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_pad();
}
inline const ::std::string& TopologyLink::src_pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyLink.src_pad)
  return src_pad_.GetNoArena();
}
inline void TopologyLink::set_src_pad(const ::std::string& value) {
  set_has_src_pad();
  src_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyLink.src_pad)
}
#if LANG_CXX11
inline void TopologyLink::set_src_pad(::std::string&& value) {
  set_has_src_pad();
  src_pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyLink.src_pad)
}
#endif
inline void TopologyLink::set_src_pad(const char* value) {
  set_has_src_pad();
  src_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyLink.src_pad)
}
inline void TopologyLink::set_src_pad(const char* value, size_t size) {
  set_has_src_pad();
  src_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyLink.src_pad)
}
inline ::std::string* TopologyLink::mutable_src_pad() {
  set_has_src_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyLink.src_pad)
  return src_pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyLink::release_src_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyLink.src_pad)
  clear_has_src_pad();
  return src_pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyLink::set_allocated_src_pad(::std::string* src_pad) {
  if (src_pad != NULL) {
    set_has_src_pad();
  } else {
    clear_has_src_pad();
  }
  src_pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyLink.src_pad)
}

// required string sink_pad = 2;
inline bool TopologyLink::has_sink_pad() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopologyLink::set_has_sink_pad() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopologyLink::clear_has_sink_pad() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopologyLink::clear_sink_pad() {
  sink_pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sink_pad();
}
inline const ::std::string& TopologyLink::sink_pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyLink.sink_pad)
  return sink_pad_.GetNoArena();
}
inline void TopologyLink::set_sink_pad(const ::std::string& value) {
  set_has_sink_pad();
  sink_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyLink.sink_pad)
}
#if LANG_CXX11
inline void TopologyLink::set_sink_pad(::std::string&& value) {
  set_has_sink_pad();
  sink_pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyLink.sink_pad)
}
#endif
inline void TopologyLink::set_sink_pad(const char* value) {
  set_has_sink_pad();
  sink_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyLink.sink_pad)
}
inline void TopologyLink::set_sink_pad(const char* value, size_t size) {
  set_has_sink_pad();
  sink_pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyLink.sink_pad)
}
inline ::std::string* TopologyLink::mutable_sink_pad() {
  set_has_sink_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyLink.sink_pad)
  return sink_pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyLink::release_sink_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyLink.sink_pad)
  clear_has_sink_pad();
  return sink_pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyLink::set_allocated_sink_pad(::std::string* sink_pad) {
  if (sink_pad != NULL) {
    set_has_sink_pad();
  } else {
    clear_has_sink_pad();
  }
  sink_pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sink_pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyLink.sink_pad)
}

// -------------------------------------------------------------------

// TopologyElement

// required string path = 1;
inline bool TopologyElement::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopologyElement::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopologyElement::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopologyElement::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& TopologyElement::path() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyElement.path)
  return path_.GetNoArena();
}
inline void TopologyElement::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyElement.path)
}
#if LANG_CXX11
inline void TopologyElement::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyElement.path)
}
#endif
inline void TopologyElement::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyElement.path)
}
inline void TopologyElement::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyElement.path)
}
inline ::std::string* TopologyElement::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyElement.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyElement::release_path() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyElement.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyElement::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyElement.path)
}

// required string type_name = 2;
inline bool TopologyElement::has_type_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopologyElement::set_has_type_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopologyElement::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopologyElement::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
inline const ::std::string& TopologyElement::type_name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyElement.type_name)
  return type_name_.GetNoArena();
}
inline void TopologyElement::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyElement.type_name)
}
#if LANG_CXX11
inline void TopologyElement::set_type_name(::std::string&& value) {
  set_has_type_name();
  type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyElement.type_name)
}
#endif
inline void TopologyElement::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyElement.type_name)
}
inline void TopologyElement::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyElement.type_name)
}
inline ::std::string* TopologyElement::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyElement.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyElement::release_type_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyElement.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyElement::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyElement.type_name)
}

// required bool is_bin = 3;
inline bool TopologyElement::has_is_bin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopologyElement::set_has_is_bin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopologyElement::clear_has_is_bin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopologyElement::clear_is_bin() {
  is_bin_ = false;
  clear_has_is_bin();
}
inline bool TopologyElement::is_bin() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyElement.is_bin)
  return is_bin_;
}
inline void TopologyElement::set_is_bin(bool value) {
  set_has_is_bin();
  is_bin_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyElement.is_bin)
}

// required string factory_name = 4;
inline bool TopologyElement::has_factory_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopologyElement::set_has_factory_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopologyElement::clear_has_factory_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopologyElement::clear_factory_name() {
  factory_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_factory_name();
}
inline const ::std::string& TopologyElement::factory_name() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyElement.factory_name)
  return factory_name_.GetNoArena();
}
inline void TopologyElement::set_factory_name(const ::std::string& value) {
  set_has_factory_name();
  factory_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyElement.factory_name)
}
#if LANG_CXX11
inline void TopologyElement::set_factory_name(::std::string&& value) {
  set_has_factory_name();
  factory_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyElement.factory_name)
}
#endif
inline void TopologyElement::set_factory_name(const char* value) {
  set_has_factory_name();
  factory_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyElement.factory_name)
}
inline void TopologyElement::set_factory_name(const char* value, size_t size) {
  set_has_factory_name();
  factory_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyElement.factory_name)
}
inline ::std::string* TopologyElement::mutable_factory_name() {
  set_has_factory_name();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyElement.factory_name)
  return factory_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyElement::release_factory_name() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyElement.factory_name)
  clear_has_factory_name();
  return factory_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyElement::set_allocated_factory_name(::std::string* factory_name) {
  if (factory_name != NULL) {
    set_has_factory_name();
  } else {
    clear_has_factory_name();
  }
  factory_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), factory_name);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyElement.factory_name)
}

// -------------------------------------------------------------------

// TopologyPad

// required string path = 1;
inline bool TopologyPad::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopologyPad::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopologyPad::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopologyPad::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& TopologyPad::path() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyPad.path)
  return path_.GetNoArena();
}
inline void TopologyPad::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyPad.path)
}
#if LANG_CXX11
inline void TopologyPad::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.TopologyPad.path)
}
#endif
inline void TopologyPad::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.TopologyPad.path)
}
inline void TopologyPad::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.TopologyPad.path)
}
inline ::std::string* TopologyPad::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyPad.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopologyPad::release_path() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyPad.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopologyPad::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyPad.path)
}

// required bool is_ghostpad = 2;
inline bool TopologyPad::has_is_ghostpad() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopologyPad::set_has_is_ghostpad() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopologyPad::clear_has_is_ghostpad() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopologyPad::clear_is_ghostpad() {
  is_ghostpad_ = false;
  clear_has_is_ghostpad();
}
inline bool TopologyPad::is_ghostpad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyPad.is_ghostpad)
  return is_ghostpad_;
}
inline void TopologyPad::set_is_ghostpad(bool value) {
  set_has_is_ghostpad();
  is_ghostpad_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyPad.is_ghostpad)
}

// required int32 direction = 3;
inline bool TopologyPad::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopologyPad::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopologyPad::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopologyPad::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 TopologyPad::direction() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyPad.direction)
  return direction_;
}
inline void TopologyPad::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyPad.direction)
}

// required int32 presence = 4;
inline bool TopologyPad::has_presence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopologyPad::set_has_presence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopologyPad::clear_has_presence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopologyPad::clear_presence() {
  presence_ = 0;
  clear_has_presence();
}
inline ::google::protobuf::int32 TopologyPad::presence() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyPad.presence)
  return presence_;
}
inline void TopologyPad::set_presence(::google::protobuf::int32 value) {
  set_has_presence();
  presence_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyPad.presence)
}

// optional .GstDebugger.PadTemplate template = 5;
inline bool TopologyPad::has_template_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopologyPad::set_has_template_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopologyPad::clear_has_template_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopologyPad::clear_template_() {
  if (template__ != NULL) template__->::GstDebugger::PadTemplate::Clear();
  clear_has_template_();
}
inline const ::GstDebugger::PadTemplate& TopologyPad::template_() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyPad.template)
  return template__ != NULL ? *template__
                         : *::GstDebugger::PadTemplate::internal_default_instance();
}
inline ::GstDebugger::PadTemplate* TopologyPad::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) {
    template__ = new ::GstDebugger::PadTemplate;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyPad.template)
  return template__;
}
inline ::GstDebugger::PadTemplate* TopologyPad::release_template_() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyPad.template)
  clear_has_template_();
  ::GstDebugger::PadTemplate* temp = template__;
  template__ = NULL;
  return temp;
}
inline void TopologyPad::set_allocated_template_(::GstDebugger::PadTemplate* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyPad.template)
}

// -------------------------------------------------------------------

// TopologyInfo

// required .GstDebugger.Action action = 1;
inline bool TopologyInfo::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopologyInfo::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopologyInfo::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopologyInfo::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::GstDebugger::Action TopologyInfo::action() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyInfo.action)
  return static_cast< ::GstDebugger::Action >(action_);
}
inline void TopologyInfo::set_action(::GstDebugger::Action value) {
  assert(::GstDebugger::Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:GstDebugger.TopologyInfo.action)
}

// optional .GstDebugger.TopologyLink link = 2;
inline bool TopologyInfo::has_link() const {
  return topology_type_case() == kLink;
}
inline void TopologyInfo::set_has_link() {
  _oneof_case_[0] = kLink;
}
inline void TopologyInfo::clear_link() {
  if (has_link()) {
    delete topology_type_.link_;
    clear_has_topology_type();
  }
}
inline  const ::GstDebugger::TopologyLink& TopologyInfo::link() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyInfo.link)
  return has_link()
      ? *topology_type_.link_
      : ::GstDebugger::TopologyLink::default_instance();
}
inline ::GstDebugger::TopologyLink* TopologyInfo::mutable_link() {
  if (!has_link()) {
    clear_topology_type();
    set_has_link();
    topology_type_.link_ = new ::GstDebugger::TopologyLink;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyInfo.link)
  return topology_type_.link_;
}
inline ::GstDebugger::TopologyLink* TopologyInfo::release_link() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyInfo.link)
  if (has_link()) {
    clear_has_topology_type();
    ::GstDebugger::TopologyLink* temp = topology_type_.link_;
    topology_type_.link_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TopologyInfo::set_allocated_link(::GstDebugger::TopologyLink* link) {
  clear_topology_type();
  if (link) {
    set_has_link();
    topology_type_.link_ = link;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyInfo.link)
}

// optional .GstDebugger.TopologyElement element = 3;
inline bool TopologyInfo::has_element() const {
  return topology_type_case() == kElement;
}
inline void TopologyInfo::set_has_element() {
  _oneof_case_[0] = kElement;
}
inline void TopologyInfo::clear_element() {
  if (has_element()) {
    delete topology_type_.element_;
    clear_has_topology_type();
  }
}
inline  const ::GstDebugger::TopologyElement& TopologyInfo::element() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyInfo.element)
  return has_element()
      ? *topology_type_.element_
      : ::GstDebugger::TopologyElement::default_instance();
}
inline ::GstDebugger::TopologyElement* TopologyInfo::mutable_element() {
  if (!has_element()) {
    clear_topology_type();
    set_has_element();
    topology_type_.element_ = new ::GstDebugger::TopologyElement;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyInfo.element)
  return topology_type_.element_;
}
inline ::GstDebugger::TopologyElement* TopologyInfo::release_element() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyInfo.element)
  if (has_element()) {
    clear_has_topology_type();
    ::GstDebugger::TopologyElement* temp = topology_type_.element_;
    topology_type_.element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TopologyInfo::set_allocated_element(::GstDebugger::TopologyElement* element) {
  clear_topology_type();
  if (element) {
    set_has_element();
    topology_type_.element_ = element;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyInfo.element)
}

// optional .GstDebugger.TopologyPad pad = 4;
inline bool TopologyInfo::has_pad() const {
  return topology_type_case() == kPad;
}
inline void TopologyInfo::set_has_pad() {
  _oneof_case_[0] = kPad;
}
inline void TopologyInfo::clear_pad() {
  if (has_pad()) {
    delete topology_type_.pad_;
    clear_has_topology_type();
  }
}
inline  const ::GstDebugger::TopologyPad& TopologyInfo::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.TopologyInfo.pad)
  return has_pad()
      ? *topology_type_.pad_
      : ::GstDebugger::TopologyPad::default_instance();
}
inline ::GstDebugger::TopologyPad* TopologyInfo::mutable_pad() {
  if (!has_pad()) {
    clear_topology_type();
    set_has_pad();
    topology_type_.pad_ = new ::GstDebugger::TopologyPad;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.TopologyInfo.pad)
  return topology_type_.pad_;
}
inline ::GstDebugger::TopologyPad* TopologyInfo::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.TopologyInfo.pad)
  if (has_pad()) {
    clear_has_topology_type();
    ::GstDebugger::TopologyPad* temp = topology_type_.pad_;
    topology_type_.pad_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TopologyInfo::set_allocated_pad(::GstDebugger::TopologyPad* pad) {
  clear_topology_type();
  if (pad) {
    set_has_pad();
    topology_type_.pad_ = pad;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.TopologyInfo.pad)
}

inline bool TopologyInfo::has_topology_type() const {
  return topology_type_case() != TOPOLOGY_TYPE_NOT_SET;
}
inline void TopologyInfo::clear_has_topology_type() {
  _oneof_case_[0] = TOPOLOGY_TYPE_NOT_SET;
}
inline TopologyInfo::TopologyTypeCase TopologyInfo::topology_type_case() const {
  return TopologyInfo::TopologyTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PadDynamicInfo

// required string allowed_caps = 1;
inline bool PadDynamicInfo::has_allowed_caps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PadDynamicInfo::set_has_allowed_caps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PadDynamicInfo::clear_has_allowed_caps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PadDynamicInfo::clear_allowed_caps() {
  allowed_caps_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_allowed_caps();
}
inline const ::std::string& PadDynamicInfo::allowed_caps() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadDynamicInfo.allowed_caps)
  return allowed_caps_.GetNoArena();
}
inline void PadDynamicInfo::set_allowed_caps(const ::std::string& value) {
  set_has_allowed_caps();
  allowed_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadDynamicInfo.allowed_caps)
}
#if LANG_CXX11
inline void PadDynamicInfo::set_allowed_caps(::std::string&& value) {
  set_has_allowed_caps();
  allowed_caps_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadDynamicInfo.allowed_caps)
}
#endif
inline void PadDynamicInfo::set_allowed_caps(const char* value) {
  set_has_allowed_caps();
  allowed_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadDynamicInfo.allowed_caps)
}
inline void PadDynamicInfo::set_allowed_caps(const char* value, size_t size) {
  set_has_allowed_caps();
  allowed_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadDynamicInfo.allowed_caps)
}
inline ::std::string* PadDynamicInfo::mutable_allowed_caps() {
  set_has_allowed_caps();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadDynamicInfo.allowed_caps)
  return allowed_caps_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadDynamicInfo::release_allowed_caps() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadDynamicInfo.allowed_caps)
  clear_has_allowed_caps();
  return allowed_caps_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadDynamicInfo::set_allocated_allowed_caps(::std::string* allowed_caps) {
  if (allowed_caps != NULL) {
    set_has_allowed_caps();
  } else {
    clear_has_allowed_caps();
  }
  allowed_caps_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), allowed_caps);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadDynamicInfo.allowed_caps)
}

// required string current_caps = 2;
inline bool PadDynamicInfo::has_current_caps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PadDynamicInfo::set_has_current_caps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PadDynamicInfo::clear_has_current_caps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PadDynamicInfo::clear_current_caps() {
  current_caps_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_current_caps();
}
inline const ::std::string& PadDynamicInfo::current_caps() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadDynamicInfo.current_caps)
  return current_caps_.GetNoArena();
}
inline void PadDynamicInfo::set_current_caps(const ::std::string& value) {
  set_has_current_caps();
  current_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadDynamicInfo.current_caps)
}
#if LANG_CXX11
inline void PadDynamicInfo::set_current_caps(::std::string&& value) {
  set_has_current_caps();
  current_caps_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadDynamicInfo.current_caps)
}
#endif
inline void PadDynamicInfo::set_current_caps(const char* value) {
  set_has_current_caps();
  current_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadDynamicInfo.current_caps)
}
inline void PadDynamicInfo::set_current_caps(const char* value, size_t size) {
  set_has_current_caps();
  current_caps_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadDynamicInfo.current_caps)
}
inline ::std::string* PadDynamicInfo::mutable_current_caps() {
  set_has_current_caps();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadDynamicInfo.current_caps)
  return current_caps_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadDynamicInfo::release_current_caps() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadDynamicInfo.current_caps)
  clear_has_current_caps();
  return current_caps_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadDynamicInfo::set_allocated_current_caps(::std::string* current_caps) {
  if (current_caps != NULL) {
    set_has_current_caps();
  } else {
    clear_has_current_caps();
  }
  current_caps_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), current_caps);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadDynamicInfo.current_caps)
}

// required string pad = 3;
inline bool PadDynamicInfo::has_pad() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PadDynamicInfo::set_has_pad() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PadDynamicInfo::clear_has_pad() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PadDynamicInfo::clear_pad() {
  pad_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pad();
}
inline const ::std::string& PadDynamicInfo::pad() const {
  // @@protoc_insertion_point(field_get:GstDebugger.PadDynamicInfo.pad)
  return pad_.GetNoArena();
}
inline void PadDynamicInfo::set_pad(const ::std::string& value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GstDebugger.PadDynamicInfo.pad)
}
#if LANG_CXX11
inline void PadDynamicInfo::set_pad(::std::string&& value) {
  set_has_pad();
  pad_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GstDebugger.PadDynamicInfo.pad)
}
#endif
inline void PadDynamicInfo::set_pad(const char* value) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GstDebugger.PadDynamicInfo.pad)
}
inline void PadDynamicInfo::set_pad(const char* value, size_t size) {
  set_has_pad();
  pad_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GstDebugger.PadDynamicInfo.pad)
}
inline ::std::string* PadDynamicInfo::mutable_pad() {
  set_has_pad();
  // @@protoc_insertion_point(field_mutable:GstDebugger.PadDynamicInfo.pad)
  return pad_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PadDynamicInfo::release_pad() {
  // @@protoc_insertion_point(field_release:GstDebugger.PadDynamicInfo.pad)
  clear_has_pad();
  return pad_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PadDynamicInfo::set_allocated_pad(::std::string* pad) {
  if (pad != NULL) {
    set_has_pad();
  } else {
    clear_has_pad();
  }
  pad_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pad);
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.PadDynamicInfo.pad)
}

// -------------------------------------------------------------------

// GStreamerData

// optional .GstDebugger.DebugCategories debug_categories = 1;
inline bool GStreamerData::has_debug_categories() const {
  return info_type_case() == kDebugCategories;
}
inline void GStreamerData::set_has_debug_categories() {
  _oneof_case_[0] = kDebugCategories;
}
inline void GStreamerData::clear_debug_categories() {
  if (has_debug_categories()) {
    delete info_type_.debug_categories_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::DebugCategories& GStreamerData::debug_categories() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.debug_categories)
  return has_debug_categories()
      ? *info_type_.debug_categories_
      : ::GstDebugger::DebugCategories::default_instance();
}
inline ::GstDebugger::DebugCategories* GStreamerData::mutable_debug_categories() {
  if (!has_debug_categories()) {
    clear_info_type();
    set_has_debug_categories();
    info_type_.debug_categories_ = new ::GstDebugger::DebugCategories;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.debug_categories)
  return info_type_.debug_categories_;
}
inline ::GstDebugger::DebugCategories* GStreamerData::release_debug_categories() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.debug_categories)
  if (has_debug_categories()) {
    clear_has_info_type();
    ::GstDebugger::DebugCategories* temp = info_type_.debug_categories_;
    info_type_.debug_categories_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_debug_categories(::GstDebugger::DebugCategories* debug_categories) {
  clear_info_type();
  if (debug_categories) {
    set_has_debug_categories();
    info_type_.debug_categories_ = debug_categories;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.debug_categories)
}

// optional .GstDebugger.LogInfo log_info = 2;
inline bool GStreamerData::has_log_info() const {
  return info_type_case() == kLogInfo;
}
inline void GStreamerData::set_has_log_info() {
  _oneof_case_[0] = kLogInfo;
}
inline void GStreamerData::clear_log_info() {
  if (has_log_info()) {
    delete info_type_.log_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::LogInfo& GStreamerData::log_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.log_info)
  return has_log_info()
      ? *info_type_.log_info_
      : ::GstDebugger::LogInfo::default_instance();
}
inline ::GstDebugger::LogInfo* GStreamerData::mutable_log_info() {
  if (!has_log_info()) {
    clear_info_type();
    set_has_log_info();
    info_type_.log_info_ = new ::GstDebugger::LogInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.log_info)
  return info_type_.log_info_;
}
inline ::GstDebugger::LogInfo* GStreamerData::release_log_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.log_info)
  if (has_log_info()) {
    clear_has_info_type();
    ::GstDebugger::LogInfo* temp = info_type_.log_info_;
    info_type_.log_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_log_info(::GstDebugger::LogInfo* log_info) {
  clear_info_type();
  if (log_info) {
    set_has_log_info();
    info_type_.log_info_ = log_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.log_info)
}

// optional .GstDebugger.EnumFlagsType enum_flags_type = 3;
inline bool GStreamerData::has_enum_flags_type() const {
  return info_type_case() == kEnumFlagsType;
}
inline void GStreamerData::set_has_enum_flags_type() {
  _oneof_case_[0] = kEnumFlagsType;
}
inline void GStreamerData::clear_enum_flags_type() {
  if (has_enum_flags_type()) {
    delete info_type_.enum_flags_type_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::EnumFlagsType& GStreamerData::enum_flags_type() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.enum_flags_type)
  return has_enum_flags_type()
      ? *info_type_.enum_flags_type_
      : ::GstDebugger::EnumFlagsType::default_instance();
}
inline ::GstDebugger::EnumFlagsType* GStreamerData::mutable_enum_flags_type() {
  if (!has_enum_flags_type()) {
    clear_info_type();
    set_has_enum_flags_type();
    info_type_.enum_flags_type_ = new ::GstDebugger::EnumFlagsType;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.enum_flags_type)
  return info_type_.enum_flags_type_;
}
inline ::GstDebugger::EnumFlagsType* GStreamerData::release_enum_flags_type() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.enum_flags_type)
  if (has_enum_flags_type()) {
    clear_has_info_type();
    ::GstDebugger::EnumFlagsType* temp = info_type_.enum_flags_type_;
    info_type_.enum_flags_type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_enum_flags_type(::GstDebugger::EnumFlagsType* enum_flags_type) {
  clear_info_type();
  if (enum_flags_type) {
    set_has_enum_flags_type();
    info_type_.enum_flags_type_ = enum_flags_type;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.enum_flags_type)
}

// optional .GstDebugger.FactoryType factory = 4;
inline bool GStreamerData::has_factory() const {
  return info_type_case() == kFactory;
}
inline void GStreamerData::set_has_factory() {
  _oneof_case_[0] = kFactory;
}
inline void GStreamerData::clear_factory() {
  if (has_factory()) {
    delete info_type_.factory_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::FactoryType& GStreamerData::factory() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.factory)
  return has_factory()
      ? *info_type_.factory_
      : ::GstDebugger::FactoryType::default_instance();
}
inline ::GstDebugger::FactoryType* GStreamerData::mutable_factory() {
  if (!has_factory()) {
    clear_info_type();
    set_has_factory();
    info_type_.factory_ = new ::GstDebugger::FactoryType;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.factory)
  return info_type_.factory_;
}
inline ::GstDebugger::FactoryType* GStreamerData::release_factory() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.factory)
  if (has_factory()) {
    clear_has_info_type();
    ::GstDebugger::FactoryType* temp = info_type_.factory_;
    info_type_.factory_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_factory(::GstDebugger::FactoryType* factory) {
  clear_info_type();
  if (factory) {
    set_has_factory();
    info_type_.factory_ = factory;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.factory)
}

// optional .GstDebugger.MessageInfo message_info = 5;
inline bool GStreamerData::has_message_info() const {
  return info_type_case() == kMessageInfo;
}
inline void GStreamerData::set_has_message_info() {
  _oneof_case_[0] = kMessageInfo;
}
inline void GStreamerData::clear_message_info() {
  if (has_message_info()) {
    delete info_type_.message_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::MessageInfo& GStreamerData::message_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.message_info)
  return has_message_info()
      ? *info_type_.message_info_
      : ::GstDebugger::MessageInfo::default_instance();
}
inline ::GstDebugger::MessageInfo* GStreamerData::mutable_message_info() {
  if (!has_message_info()) {
    clear_info_type();
    set_has_message_info();
    info_type_.message_info_ = new ::GstDebugger::MessageInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.message_info)
  return info_type_.message_info_;
}
inline ::GstDebugger::MessageInfo* GStreamerData::release_message_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.message_info)
  if (has_message_info()) {
    clear_has_info_type();
    ::GstDebugger::MessageInfo* temp = info_type_.message_info_;
    info_type_.message_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_message_info(::GstDebugger::MessageInfo* message_info) {
  clear_info_type();
  if (message_info) {
    set_has_message_info();
    info_type_.message_info_ = message_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.message_info)
}

// optional .GstDebugger.Command confirmation = 6;
inline bool GStreamerData::has_confirmation() const {
  return info_type_case() == kConfirmation;
}
inline void GStreamerData::set_has_confirmation() {
  _oneof_case_[0] = kConfirmation;
}
inline void GStreamerData::clear_confirmation() {
  if (has_confirmation()) {
    delete info_type_.confirmation_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::Command& GStreamerData::confirmation() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.confirmation)
  return has_confirmation()
      ? *info_type_.confirmation_
      : ::GstDebugger::Command::default_instance();
}
inline ::GstDebugger::Command* GStreamerData::mutable_confirmation() {
  if (!has_confirmation()) {
    clear_info_type();
    set_has_confirmation();
    info_type_.confirmation_ = new ::GstDebugger::Command;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.confirmation)
  return info_type_.confirmation_;
}
inline ::GstDebugger::Command* GStreamerData::release_confirmation() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.confirmation)
  if (has_confirmation()) {
    clear_has_info_type();
    ::GstDebugger::Command* temp = info_type_.confirmation_;
    info_type_.confirmation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_confirmation(::GstDebugger::Command* confirmation) {
  clear_info_type();
  if (confirmation) {
    set_has_confirmation();
    info_type_.confirmation_ = confirmation;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.confirmation)
}

// optional .GstDebugger.EventInfo event_info = 7;
inline bool GStreamerData::has_event_info() const {
  return info_type_case() == kEventInfo;
}
inline void GStreamerData::set_has_event_info() {
  _oneof_case_[0] = kEventInfo;
}
inline void GStreamerData::clear_event_info() {
  if (has_event_info()) {
    delete info_type_.event_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::EventInfo& GStreamerData::event_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.event_info)
  return has_event_info()
      ? *info_type_.event_info_
      : ::GstDebugger::EventInfo::default_instance();
}
inline ::GstDebugger::EventInfo* GStreamerData::mutable_event_info() {
  if (!has_event_info()) {
    clear_info_type();
    set_has_event_info();
    info_type_.event_info_ = new ::GstDebugger::EventInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.event_info)
  return info_type_.event_info_;
}
inline ::GstDebugger::EventInfo* GStreamerData::release_event_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.event_info)
  if (has_event_info()) {
    clear_has_info_type();
    ::GstDebugger::EventInfo* temp = info_type_.event_info_;
    info_type_.event_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_event_info(::GstDebugger::EventInfo* event_info) {
  clear_info_type();
  if (event_info) {
    set_has_event_info();
    info_type_.event_info_ = event_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.event_info)
}

// optional .GstDebugger.TopologyInfo topology_info = 8;
inline bool GStreamerData::has_topology_info() const {
  return info_type_case() == kTopologyInfo;
}
inline void GStreamerData::set_has_topology_info() {
  _oneof_case_[0] = kTopologyInfo;
}
inline void GStreamerData::clear_topology_info() {
  if (has_topology_info()) {
    delete info_type_.topology_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::TopologyInfo& GStreamerData::topology_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.topology_info)
  return has_topology_info()
      ? *info_type_.topology_info_
      : ::GstDebugger::TopologyInfo::default_instance();
}
inline ::GstDebugger::TopologyInfo* GStreamerData::mutable_topology_info() {
  if (!has_topology_info()) {
    clear_info_type();
    set_has_topology_info();
    info_type_.topology_info_ = new ::GstDebugger::TopologyInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.topology_info)
  return info_type_.topology_info_;
}
inline ::GstDebugger::TopologyInfo* GStreamerData::release_topology_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.topology_info)
  if (has_topology_info()) {
    clear_has_info_type();
    ::GstDebugger::TopologyInfo* temp = info_type_.topology_info_;
    info_type_.topology_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_topology_info(::GstDebugger::TopologyInfo* topology_info) {
  clear_info_type();
  if (topology_info) {
    set_has_topology_info();
    info_type_.topology_info_ = topology_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.topology_info)
}

// optional .GstDebugger.QueryInfo query_info = 9;
inline bool GStreamerData::has_query_info() const {
  return info_type_case() == kQueryInfo;
}
inline void GStreamerData::set_has_query_info() {
  _oneof_case_[0] = kQueryInfo;
}
inline void GStreamerData::clear_query_info() {
  if (has_query_info()) {
    delete info_type_.query_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::QueryInfo& GStreamerData::query_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.query_info)
  return has_query_info()
      ? *info_type_.query_info_
      : ::GstDebugger::QueryInfo::default_instance();
}
inline ::GstDebugger::QueryInfo* GStreamerData::mutable_query_info() {
  if (!has_query_info()) {
    clear_info_type();
    set_has_query_info();
    info_type_.query_info_ = new ::GstDebugger::QueryInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.query_info)
  return info_type_.query_info_;
}
inline ::GstDebugger::QueryInfo* GStreamerData::release_query_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.query_info)
  if (has_query_info()) {
    clear_has_info_type();
    ::GstDebugger::QueryInfo* temp = info_type_.query_info_;
    info_type_.query_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_query_info(::GstDebugger::QueryInfo* query_info) {
  clear_info_type();
  if (query_info) {
    set_has_query_info();
    info_type_.query_info_ = query_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.query_info)
}

// optional .GstDebugger.PropertyValue property_value = 10;
inline bool GStreamerData::has_property_value() const {
  return info_type_case() == kPropertyValue;
}
inline void GStreamerData::set_has_property_value() {
  _oneof_case_[0] = kPropertyValue;
}
inline void GStreamerData::clear_property_value() {
  if (has_property_value()) {
    delete info_type_.property_value_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::PropertyValue& GStreamerData::property_value() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.property_value)
  return has_property_value()
      ? *info_type_.property_value_
      : ::GstDebugger::PropertyValue::default_instance();
}
inline ::GstDebugger::PropertyValue* GStreamerData::mutable_property_value() {
  if (!has_property_value()) {
    clear_info_type();
    set_has_property_value();
    info_type_.property_value_ = new ::GstDebugger::PropertyValue;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.property_value)
  return info_type_.property_value_;
}
inline ::GstDebugger::PropertyValue* GStreamerData::release_property_value() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.property_value)
  if (has_property_value()) {
    clear_has_info_type();
    ::GstDebugger::PropertyValue* temp = info_type_.property_value_;
    info_type_.property_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_property_value(::GstDebugger::PropertyValue* property_value) {
  clear_info_type();
  if (property_value) {
    set_has_property_value();
    info_type_.property_value_ = property_value;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.property_value)
}

// optional .GstDebugger.ElementKlass element_klass = 11;
inline bool GStreamerData::has_element_klass() const {
  return info_type_case() == kElementKlass;
}
inline void GStreamerData::set_has_element_klass() {
  _oneof_case_[0] = kElementKlass;
}
inline void GStreamerData::clear_element_klass() {
  if (has_element_klass()) {
    delete info_type_.element_klass_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::ElementKlass& GStreamerData::element_klass() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.element_klass)
  return has_element_klass()
      ? *info_type_.element_klass_
      : ::GstDebugger::ElementKlass::default_instance();
}
inline ::GstDebugger::ElementKlass* GStreamerData::mutable_element_klass() {
  if (!has_element_klass()) {
    clear_info_type();
    set_has_element_klass();
    info_type_.element_klass_ = new ::GstDebugger::ElementKlass;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.element_klass)
  return info_type_.element_klass_;
}
inline ::GstDebugger::ElementKlass* GStreamerData::release_element_klass() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.element_klass)
  if (has_element_klass()) {
    clear_has_info_type();
    ::GstDebugger::ElementKlass* temp = info_type_.element_klass_;
    info_type_.element_klass_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_element_klass(::GstDebugger::ElementKlass* element_klass) {
  clear_info_type();
  if (element_klass) {
    set_has_element_klass();
    info_type_.element_klass_ = element_klass;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.element_klass)
}

// optional .GstDebugger.BufferInfo buffer_info = 12;
inline bool GStreamerData::has_buffer_info() const {
  return info_type_case() == kBufferInfo;
}
inline void GStreamerData::set_has_buffer_info() {
  _oneof_case_[0] = kBufferInfo;
}
inline void GStreamerData::clear_buffer_info() {
  if (has_buffer_info()) {
    delete info_type_.buffer_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::BufferInfo& GStreamerData::buffer_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.buffer_info)
  return has_buffer_info()
      ? *info_type_.buffer_info_
      : ::GstDebugger::BufferInfo::default_instance();
}
inline ::GstDebugger::BufferInfo* GStreamerData::mutable_buffer_info() {
  if (!has_buffer_info()) {
    clear_info_type();
    set_has_buffer_info();
    info_type_.buffer_info_ = new ::GstDebugger::BufferInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.buffer_info)
  return info_type_.buffer_info_;
}
inline ::GstDebugger::BufferInfo* GStreamerData::release_buffer_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.buffer_info)
  if (has_buffer_info()) {
    clear_has_info_type();
    ::GstDebugger::BufferInfo* temp = info_type_.buffer_info_;
    info_type_.buffer_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_buffer_info(::GstDebugger::BufferInfo* buffer_info) {
  clear_info_type();
  if (buffer_info) {
    set_has_buffer_info();
    info_type_.buffer_info_ = buffer_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.buffer_info)
}

// optional .GstDebugger.PadDynamicInfo pad_dynamic_info = 13;
inline bool GStreamerData::has_pad_dynamic_info() const {
  return info_type_case() == kPadDynamicInfo;
}
inline void GStreamerData::set_has_pad_dynamic_info() {
  _oneof_case_[0] = kPadDynamicInfo;
}
inline void GStreamerData::clear_pad_dynamic_info() {
  if (has_pad_dynamic_info()) {
    delete info_type_.pad_dynamic_info_;
    clear_has_info_type();
  }
}
inline  const ::GstDebugger::PadDynamicInfo& GStreamerData::pad_dynamic_info() const {
  // @@protoc_insertion_point(field_get:GstDebugger.GStreamerData.pad_dynamic_info)
  return has_pad_dynamic_info()
      ? *info_type_.pad_dynamic_info_
      : ::GstDebugger::PadDynamicInfo::default_instance();
}
inline ::GstDebugger::PadDynamicInfo* GStreamerData::mutable_pad_dynamic_info() {
  if (!has_pad_dynamic_info()) {
    clear_info_type();
    set_has_pad_dynamic_info();
    info_type_.pad_dynamic_info_ = new ::GstDebugger::PadDynamicInfo;
  }
  // @@protoc_insertion_point(field_mutable:GstDebugger.GStreamerData.pad_dynamic_info)
  return info_type_.pad_dynamic_info_;
}
inline ::GstDebugger::PadDynamicInfo* GStreamerData::release_pad_dynamic_info() {
  // @@protoc_insertion_point(field_release:GstDebugger.GStreamerData.pad_dynamic_info)
  if (has_pad_dynamic_info()) {
    clear_has_info_type();
    ::GstDebugger::PadDynamicInfo* temp = info_type_.pad_dynamic_info_;
    info_type_.pad_dynamic_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GStreamerData::set_allocated_pad_dynamic_info(::GstDebugger::PadDynamicInfo* pad_dynamic_info) {
  clear_info_type();
  if (pad_dynamic_info) {
    set_has_pad_dynamic_info();
    info_type_.pad_dynamic_info_ = pad_dynamic_info;
  }
  // @@protoc_insertion_point(field_set_allocated:GstDebugger.GStreamerData.pad_dynamic_info)
}

inline bool GStreamerData::has_info_type() const {
  return info_type_case() != INFO_TYPE_NOT_SET;
}
inline void GStreamerData::clear_has_info_type() {
  _oneof_case_[0] = INFO_TYPE_NOT_SET;
}
inline GStreamerData::InfoTypeCase GStreamerData::info_type_case() const {
  return GStreamerData::InfoTypeCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace GstDebugger

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::GstDebugger::TypeDescriptionRequest_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GstDebugger::TypeDescriptionRequest_Type>() {
  return ::GstDebugger::TypeDescriptionRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::GstDebugger::EnumFlagsType_EnumFlagsKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GstDebugger::EnumFlagsType_EnumFlagsKind>() {
  return ::GstDebugger::EnumFlagsType_EnumFlagsKind_descriptor();
}
template <> struct is_proto_enum< ::GstDebugger::Action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GstDebugger::Action>() {
  return ::GstDebugger::Action_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gstdebugger_2eproto__INCLUDED
